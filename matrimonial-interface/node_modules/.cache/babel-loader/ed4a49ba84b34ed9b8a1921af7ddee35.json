{"ast":null,"code":"/**\n * Created by james on 23/02/2017.\n */\n(function ($) {\n  var DraggablePiechart = function DraggablePiechart(setup) {\n    var piechart = this;\n    setup = $.extend(true, {}, this.defaults, setup);\n    this.canvas = setup.canvas;\n    this.$canvas = $(setup.canvas);\n    this.context = setup.canvas.getContext(\"2d\");\n\n    if (!this.context) {\n      console.log('Error: DraggablePiechart needs an html5 canvas.');\n      return;\n    }\n\n    if (setup.proportions) {\n      this.data = generateDataFromProportions(setup.proportions);\n    } else if (setup.data) {\n      this.data = setup.data;\n    }\n\n    this.draggedPie = null;\n    this.hoveredIndex = -1;\n    this.radius = setup.radius;\n    this.collapsing = setup.collapsing;\n    this.minAngle = setup.minAngle;\n    this.drawSegment = setup.drawSegment;\n    this.drawNode = setup.drawNode;\n    this.onchange = setup.onchange; // Events, touch is processed before mouse,\n    // prevent default to prevent propogation\n\n    this.$canvas.bind('touchstart', function (e) {\n      touchStart(e);\n      e.preventDefault();\n    });\n    this.$canvas.bind('touchmove', function (e) {\n      touchMove(e);\n      e.preventDefault();\n    });\n    $(document).bind('touchend', function (e) {\n      touchEnd(e);\n    });\n    this.$canvas.mousedown(touchStart);\n    this.$canvas.mousemove(touchMove);\n    $(document).mouseup(touchEnd);\n    this.draw();\n\n    function touchStart(event) {\n      piechart.draggedPie = piechart.getTarget(getMouseLocation(event));\n\n      if (piechart.draggedPie) {\n        piechart.hoveredIndex = piechart.draggedPie.index;\n      }\n    }\n\n    function touchEnd() {\n      piechart.draggedPie = null;\n      piechart.draw();\n    }\n\n    function touchMove(event) {\n      var dragLocation = getMouseLocation(event);\n\n      if (!piechart.draggedPie) {\n        var hoveredTarget = piechart.getTarget(dragLocation);\n\n        if (hoveredTarget) {\n          piechart.hoveredIndex = hoveredTarget.index;\n          piechart.draw();\n        } else if (piechart.hoveredIndex != -1) {\n          piechart.hoveredIndex = -1;\n          piechart.draw();\n        }\n\n        return;\n      }\n\n      var draggedPie = piechart.draggedPie;\n      var dx = dragLocation.x - draggedPie.centerX;\n      var dy = dragLocation.y - draggedPie.centerY; // Get angle of grabbed target from centre of pie\n\n      var newAngle = Math.atan2(dy, dx) - draggedPie.angleOffset;\n      piechart.shiftSelectedAngle(newAngle);\n      piechart.draw();\n    }\n\n    function getMouseLocation(evt) {\n      var rect = piechart.canvas.getBoundingClientRect();\n\n      if (evt.clientX) {\n        return {\n          x: evt.clientX - rect.left,\n          y: evt.clientY - rect.top\n        };\n      } else {\n        return {\n          x: evt.originalEvent.targetTouches[0].clientX - rect.left,\n          y: evt.originalEvent.targetTouches[0].clientY - rect.top\n        };\n      }\n    }\n    /*\n     * Generates angle data from proportions (array of objects with proportion, format\n     */\n\n\n    function generateDataFromProportions(proportions) {\n      // sum of proportions\n      var total = proportions.reduce(function (a, v) {\n        return a + v.proportion;\n      }, 0); // begin at 0\n\n      var currentAngle = 0; // use the proportions to reconstruct angles\n\n      return proportions.map(function (v, i) {\n        var arcSize = TAU * v.proportion / total;\n        var data = {\n          angle: currentAngle,\n          format: v.format,\n          collapsed: arcSize <= 0\n        };\n        currentAngle = normaliseAngle(currentAngle + arcSize);\n        return data;\n      });\n    }\n  };\n  /*\n   * Move angle specified by index: i, by amount: angle in rads\n   */\n\n\n  DraggablePiechart.prototype.moveAngle = function (i, amount) {\n    if (this.data[i].collapsed && amount < 0) {\n      this.setCollapsed(i, false);\n      return;\n    }\n\n    var geometry = this.getGeometry();\n    this.draggedPie = {\n      index: i,\n      angleOffset: 0,\n      centerX: geometry.centerX,\n      centerY: geometry.centerY,\n      startingAngles: this.data.map(function (v) {\n        return v.angle;\n      }),\n      collapsed: this.data.map(function (v) {\n        return v.collapsed;\n      }),\n      angleDragDistance: 0\n    };\n    this.shiftSelectedAngle(this.data[i].angle + amount);\n    this.draggedPie = null;\n    this.draw();\n  };\n  /*\n   * Gets percentage of indexed slice\n   */\n\n\n  DraggablePiechart.prototype.getSliceSizePercentage = function (index) {\n    var visibleSegments = this.getVisibleSegments();\n\n    for (var i = 0; i < visibleSegments.length; i += 1) {\n      if (visibleSegments[i].index == index) {\n        return 100 * visibleSegments[i].arcSize / TAU;\n      }\n    }\n\n    return 0;\n  };\n  /*\n   * Gets all percentages for each slice\n   */\n\n\n  DraggablePiechart.prototype.getAllSliceSizePercentages = function () {\n    var visibleSegments = this.getVisibleSegments();\n    var percentages = [];\n\n    for (var i = 0; i < this.data.length; i += 1) {\n      if (this.data[i].collapsed) {\n        percentages[i] = 0;\n      } else {\n        for (var j = 0; j < visibleSegments.length; j += 1) {\n          if (visibleSegments[j].index == i) {\n            percentages[i] = 100 * visibleSegments[j].arcSize / TAU;\n          }\n        }\n      }\n    }\n\n    return percentages;\n  };\n  /*\n   * Gets the geometry of the pie chart in the canvas\n   */\n\n\n  DraggablePiechart.prototype.getGeometry = function () {\n    var centerX = Math.floor(this.canvas.width / 2);\n    var centerY = Math.floor(this.canvas.height / 2);\n    return {\n      centerX: centerX,\n      centerY: centerY,\n      radius: Math.min(centerX, centerY) * this.radius\n    };\n  };\n  /*\n   * Returns a segment to drag if given a close enough location\n   */\n\n\n  DraggablePiechart.prototype.getTarget = function (targetLocation) {\n    var geometry = this.getGeometry();\n    var startingAngles = [];\n    var collapsed = [];\n    var closest = {\n      index: -1,\n      distance: 9999999,\n      angle: null\n    };\n\n    for (var i = 0; i < this.data.length; i += 1) {\n      startingAngles.push(this.data[i].angle);\n      collapsed.push(this.data[i].collapsed);\n\n      if (this.data[i].collapsed) {\n        continue;\n      }\n\n      var dx = targetLocation.x - geometry.centerX;\n      var dy = targetLocation.y - geometry.centerY;\n      var trueGrabbedAngle = Math.atan2(dy, dx);\n      var distance = Math.abs(smallestSignedAngleBetween(trueGrabbedAngle, this.data[i].angle));\n\n      if (distance < closest.distance) {\n        closest.index = i;\n        closest.distance = distance;\n        closest.angle = trueGrabbedAngle;\n      }\n    }\n\n    if (closest.distance < 0.1) {\n      return {\n        index: closest.index,\n        angleOffset: smallestSignedAngleBetween(closest.angle, startingAngles[closest.index]),\n        centerX: geometry.centerX,\n        centerY: geometry.centerY,\n        startingAngles: startingAngles,\n        collapsed: collapsed,\n        angleDragDistance: 0\n      };\n    } else {\n      return null;\n    }\n  };\n  /*\n   * Sets segments collapsed or uncollapsed\n   */\n\n\n  DraggablePiechart.prototype.setCollapsed = function (index, collapsed) {\n    // Flag to set position of previously collapsed to new location\n    var setNewPos = this.data[index].collapsed && !collapsed;\n    this.data[index].collapsed = collapsed;\n    var visibleSegments = this.getVisibleSegments(); // Shift other segments along to make space if necessary\n\n    for (var i = 0; i < visibleSegments.length; i += 1) {\n      // Start at this segment\n      if (visibleSegments[i].index == index) {\n        //Set new position\n        if (setNewPos) {\n          var nextSegment = visibleSegments[mod(i + 1, visibleSegments.length)];\n          this.data[index].angle = nextSegment.angle - this.minAngle;\n        }\n\n        for (var j = 0; j < visibleSegments.length - 1; j += 1) {\n          var currentSegment = visibleSegments[mod(1 + i - j, visibleSegments.length)];\n          var nextAlongSegment = visibleSegments[mod(i - j, visibleSegments.length)];\n          var angleBetween = Math.abs(smallestSignedAngleBetween(this.data[currentSegment.index].angle, this.data[nextAlongSegment.index].angle));\n\n          if (angleBetween < this.minAngle) {\n            this.data[nextAlongSegment.index].angle = normaliseAngle(this.data[currentSegment.index].angle - this.minAngle);\n          }\n        }\n\n        break;\n      }\n    }\n\n    this.draw();\n  };\n  /*\n   * Returns visible segments\n   */\n\n\n  DraggablePiechart.prototype.getVisibleSegments = function () {\n    var piechart = this; // Collect data for visible segments\n\n    var visibleSegments = [];\n\n    for (var i = 0; i < piechart.data.length; i += 1) {\n      if (!piechart.data[i].collapsed) {\n        var startingAngle = piechart.data[i].angle; // Get arcSize\n\n        var foundNextAngle = false;\n\n        for (var j = 1; j < piechart.data.length; j += 1) {\n          var nextAngleIndex = (i + j) % piechart.data.length;\n\n          if (!piechart.data[nextAngleIndex].collapsed) {\n            var arcSize = piechart.data[nextAngleIndex].angle - startingAngle;\n\n            if (arcSize <= 0) {\n              arcSize += TAU;\n            }\n\n            visibleSegments.push({\n              arcSize: arcSize,\n              angle: startingAngle,\n              format: piechart.data[i].format,\n              index: i\n            });\n            foundNextAngle = true;\n            break;\n          }\n        } // Only one segment\n\n\n        if (!foundNextAngle) {\n          visibleSegments.push({\n            arcSize: TAU,\n            angle: startingAngle,\n            format: piechart.data[i].format,\n            index: i\n          });\n          break;\n        }\n      }\n    }\n\n    return visibleSegments;\n  };\n  /*\n   * Returns invisible segments\n   */\n\n\n  DraggablePiechart.prototype.getInvisibleSegments = function () {\n    var piechart = this; // Collect data for visible segments\n\n    var invisibleSegments = [];\n\n    for (var i = 0; i < piechart.data.length; i += 1) {\n      if (piechart.data[i].collapsed) {\n        invisibleSegments.push({\n          index: i,\n          format: piechart.data[i].format\n        });\n      }\n    }\n\n    return invisibleSegments;\n  };\n  /*\n   * Draws the piechart\n   */\n\n\n  DraggablePiechart.prototype.draw = function () {\n    var piechart = this;\n    var context = piechart.context;\n    var canvas = piechart.canvas;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    var geometry = this.getGeometry();\n    var visibleSegments = this.getVisibleSegments(); // Flags to get arc sizes and index of largest arc, for drawing order\n\n    var largestArcSize = 0;\n    var indexLargestArcSize = -1; // Get the largeset arcsize\n\n    for (var i = 0; i < visibleSegments.length; i += 1) {\n      if (visibleSegments[i].arcSize > largestArcSize) {\n        largestArcSize = visibleSegments[i].arcSize;\n        indexLargestArcSize = i;\n      }\n    } // Need to draw in correct order\n\n\n    for (i = 0; i < visibleSegments.length; i += 1) {\n      // Start with one *after* largest\n      var index = mod(i + indexLargestArcSize + 1, visibleSegments.length);\n      piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, visibleSegments[index].angle, visibleSegments[index].arcSize, visibleSegments[index].format, false);\n    } // Now draw invisible segments\n\n\n    var invisibleSegments = this.getInvisibleSegments();\n\n    for (i = 0; i < invisibleSegments.length; i += 1) {\n      piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, 0, 0, invisibleSegments[i].format, true);\n    } // Finally draw drag nodes on top (order not important)\n\n\n    for (i = 0; i < visibleSegments.length; i += 1) {\n      var location = polarToCartesian(visibleSegments[i].angle, geometry.radius);\n      piechart.drawNode(context, piechart, location.x, location.y, geometry.centerX, geometry.centerY, i == piechart.hoveredIndex);\n    }\n\n    piechart.onchange(piechart);\n  };\n  /*\n   * *INTERNAL USE ONLY*\n   * Moves the selected angle to a new angle\n   */\n\n\n  DraggablePiechart.prototype.shiftSelectedAngle = function (newAngle) {\n    var piechart = this;\n\n    if (!piechart.draggedPie) {\n      return;\n    }\n\n    var draggedPie = piechart.draggedPie; // Get starting angle of the target\n\n    var startingAngle = draggedPie.startingAngles[draggedPie.index]; // Get previous angle of the target\n\n    var previousAngle = piechart.data[draggedPie.index].angle; // Get diff from grabbed target start (as -pi to +pi)\n\n    var angleDragDistance = smallestSignedAngleBetween(newAngle, startingAngle); // Get previous diff\n\n    var previousDragDistance = draggedPie.angleDragDistance; // Determines whether we go clockwise or anticlockwise\n\n    var rotationDirection = previousDragDistance > 0 ? 1 : -1; // Reverse the direction if we have done over 180 in either direction\n\n    var sameDirection = previousDragDistance > 0 == angleDragDistance > 0;\n    var greaterThanHalf = Math.abs(previousDragDistance - angleDragDistance) > Math.PI;\n\n    if (greaterThanHalf && !sameDirection) {\n      // Reverse the angle\n      angleDragDistance = (TAU - Math.abs(angleDragDistance)) * rotationDirection;\n    } else {\n      rotationDirection = angleDragDistance > 0 ? 1 : -1;\n    }\n\n    draggedPie.angleDragDistance = angleDragDistance; // Set the new angle:\n\n    piechart.data[draggedPie.index].angle = normaliseAngle(startingAngle + angleDragDistance); // Reset Collapse\n\n    piechart.data[draggedPie.index].collapsed = draggedPie.collapsed[draggedPie.index]; // Search other angles\n\n    var shifting = true;\n    var collapsed = false;\n    var minAngle = piechart.minAngle;\n    var numberOfAnglesShifted = 0;\n\n    for (var i = 1; i < piechart.data.length; i += 1) {\n      // Index to test each slice in order\n      var index = mod(draggedPie.index + i * rotationDirection, piechart.data.length); // Get angle from target start to this angle\n\n      var startingAngleToNonDragged = smallestSignedAngleBetween(draggedPie.startingAngles[index], startingAngle); // If angle is in the wrong direction then it should actually be OVER 180\n\n      if (startingAngleToNonDragged * rotationDirection < 0) {\n        startingAngleToNonDragged = (startingAngleToNonDragged * rotationDirection + TAU) * rotationDirection;\n      }\n\n      if (piechart.collapsing) {\n        // *Collapsing behaviour* when smallest angle encountered\n        // Reset collapse\n        piechart.data[index].collapsed = draggedPie.collapsed[index];\n        var checkForSnap = !collapsed && !piechart.data[index].collapsed; // Snap node to collapse, and prevent going any further\n\n        if (checkForSnap && startingAngleToNonDragged > 0 && angleDragDistance > startingAngleToNonDragged - minAngle) {\n          piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n          piechart.data[draggedPie.index].collapsed = true;\n          collapsed = true;\n        } else if (checkForSnap && startingAngleToNonDragged < 0 && angleDragDistance < startingAngleToNonDragged + minAngle) {\n          piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n          piechart.data[index].collapsed = true;\n          collapsed = true;\n        } else {\n          piechart.data[index].angle = draggedPie.startingAngles[index];\n        }\n      } else {\n        // *Shifting behaviour* when smallest angle encountered\n        // Shift all other angles along\n        var shift = (numberOfAnglesShifted + 1) * minAngle;\n\n        if (shifting && startingAngleToNonDragged > 0 && angleDragDistance > startingAngleToNonDragged - shift) {\n          piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] + (angleDragDistance - startingAngleToNonDragged) + shift);\n          numberOfAnglesShifted += 1;\n        } else if (shifting && startingAngleToNonDragged < 0 && angleDragDistance < startingAngleToNonDragged + shift) {\n          piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] - (startingAngleToNonDragged - angleDragDistance) - shift);\n          numberOfAnglesShifted += 1;\n        } else {\n          shifting = false;\n          piechart.data[index].angle = draggedPie.startingAngles[index];\n        }\n      } //console.log(JSON.stringify(piechart.data));\n\n    }\n  };\n\n  DraggablePiechart.prototype.defaults = {\n    onchange: function onchange(piechart) {},\n    radius: 0.9,\n    data: [{\n      angle: -2,\n      format: {\n        color: \"#2665da\",\n        label: 'Walking'\n      },\n      collapsed: false\n    }, {\n      angle: -1,\n      format: {\n        color: \"#6dd020\",\n        label: 'Programming'\n      },\n      collapsed: false\n    }, {\n      angle: 0,\n      format: {\n        color: \"#f9df18\",\n        label: 'Chess'\n      },\n      collapsed: false\n    }, {\n      angle: 1,\n      format: {\n        color: \"#d42a00\",\n        label: 'Eating'\n      },\n      collapsed: false\n    }, {\n      angle: 2,\n      format: {\n        color: \"#e96400\",\n        label: 'Sleeping'\n      },\n      collapsed: false\n    }],\n    collapsing: false,\n    minAngle: 0.1,\n    drawSegment: function drawSegment(context, piechart, centerX, centerY, radius, startingAngle, arcSize, format, collapsed) {\n      if (collapsed) {\n        return;\n      } // Draw coloured segment\n\n\n      context.save();\n      var endingAngle = startingAngle + arcSize;\n      context.beginPath();\n      context.moveTo(centerX, centerY);\n      context.arc(centerX, centerY, radius, startingAngle, endingAngle, false);\n      context.closePath();\n      context.fillStyle = format.color;\n      context.fill();\n      context.restore(); // Draw label on top\n\n      context.save();\n      context.translate(centerX, centerY);\n      context.rotate(startingAngle);\n      var fontSize = Math.floor(context.canvas.height / 25);\n      var dx = radius - fontSize;\n      var dy = centerY / 10;\n      context.textAlign = \"right\";\n      context.font = fontSize + \"pt Helvetica\";\n      context.fillText(format.label, dx, dy);\n      context.restore();\n    },\n    drawNode: function drawNode(context, piechart, x, y, centerX, centerY, hover) {\n      context.save();\n      context.translate(centerX, centerY);\n      context.fillStyle = '#DDDDDD';\n      var rad = hover ? 7 : 5;\n      context.beginPath();\n      context.arc(x, y, rad, 0, TAU, true);\n      context.fill();\n      context.stroke();\n      context.restore();\n    }\n  };\n  window.DraggablePiechart = DraggablePiechart;\n  /*\n   * Utilities + Constants\n   */\n\n  var TAU = Math.PI * 2;\n\n  function degreesToRadians(degrees) {\n    return degrees * Math.PI / 180;\n  }\n\n  function smallestSignedAngleBetween(target, source) {\n    return Math.atan2(Math.sin(target - source), Math.cos(target - source));\n  }\n\n  function mod(n, m) {\n    return (n % m + m) % m;\n  }\n\n  function is_touch_device() {\n    return 'ontouchstart' in window // works on most browsers\n    || navigator.maxTouchPoints; // works on IE10/11 and Surface\n  }\n\n  function normaliseAngle(angle) {\n    return mod(angle + Math.PI, TAU) - Math.PI;\n  }\n\n  function polarToCartesian(angle, radius) {\n    return {\n      x: radius * Math.cos(angle),\n      y: radius * Math.sin(angle)\n    };\n  }\n})(jQuery);","map":{"version":3,"sources":["/Users/jvlyndark/Documents/Matrimonial Interfaces/matrimonial-interface/matrimonial-interface/matrimonial-interface/app/javascript/packs/draggable-piechart-jquery.js"],"names":["$","DraggablePiechart","setup","piechart","extend","defaults","canvas","$canvas","context","getContext","console","log","proportions","data","generateDataFromProportions","draggedPie","hoveredIndex","radius","collapsing","minAngle","drawSegment","drawNode","onchange","bind","e","touchStart","preventDefault","touchMove","document","touchEnd","mousedown","mousemove","mouseup","draw","event","getTarget","getMouseLocation","index","dragLocation","hoveredTarget","dx","x","centerX","dy","y","centerY","newAngle","Math","atan2","angleOffset","shiftSelectedAngle","evt","rect","getBoundingClientRect","clientX","left","clientY","top","originalEvent","targetTouches","total","reduce","a","v","proportion","currentAngle","map","i","arcSize","TAU","angle","format","collapsed","normaliseAngle","prototype","moveAngle","amount","setCollapsed","geometry","getGeometry","startingAngles","angleDragDistance","getSliceSizePercentage","visibleSegments","getVisibleSegments","length","getAllSliceSizePercentages","percentages","j","floor","width","height","min","targetLocation","closest","distance","push","trueGrabbedAngle","abs","smallestSignedAngleBetween","setNewPos","nextSegment","mod","currentSegment","nextAlongSegment","angleBetween","startingAngle","foundNextAngle","nextAngleIndex","getInvisibleSegments","invisibleSegments","clearRect","largestArcSize","indexLargestArcSize","location","polarToCartesian","previousAngle","previousDragDistance","rotationDirection","sameDirection","greaterThanHalf","PI","shifting","numberOfAnglesShifted","startingAngleToNonDragged","checkForSnap","shift","color","label","save","endingAngle","beginPath","moveTo","arc","closePath","fillStyle","fill","restore","translate","rotate","fontSize","textAlign","font","fillText","hover","rad","stroke","window","degreesToRadians","degrees","target","source","sin","cos","n","m","is_touch_device","navigator","maxTouchPoints","jQuery"],"mappings":"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","sourcesContent":["/**\n * Created by james on 23/02/2017.\n */\n\n(function ($) {\n\n    var DraggablePiechart = function (setup) {\n\n        var piechart = this;\n\n        setup = $.extend(true, {}, this.defaults, setup);\n\n\n        this.canvas = setup.canvas;\n        this.$canvas = $(setup.canvas);\n        this.context = setup.canvas.getContext(\"2d\");\n\n        if (!this.context) {\n            console.log('Error: DraggablePiechart needs an html5 canvas.');\n            return;\n        }\n\n        if (setup.proportions) {\n            this.data = generateDataFromProportions(setup.proportions);\n        } else if (setup.data) {\n            this.data = setup.data;\n        }\n\n        this.draggedPie = null;\n        this.hoveredIndex = -1;\n        this.radius = setup.radius;\n        this.collapsing = setup.collapsing;\n        this.minAngle = setup.minAngle;\n        this.drawSegment = setup.drawSegment;\n        this.drawNode = setup.drawNode;\n        this.onchange = setup.onchange;\n\n        // Events, touch is processed before mouse,\n        // prevent default to prevent propogation\n        this.$canvas.bind('touchstart', function (e) {\n            touchStart(e);\n            e.preventDefault();\n        });\n        this.$canvas.bind('touchmove', function (e) {\n            touchMove(e);\n            e.preventDefault();\n        });\n        $(document).bind('touchend', function (e) {\n            touchEnd(e);\n        });\n\n        this.$canvas.mousedown(touchStart);\n        this.$canvas.mousemove(touchMove);\n        $(document).mouseup(touchEnd);\n\n\n        this.draw();\n\n        function touchStart(event) {\n\n\n            piechart.draggedPie = piechart.getTarget(getMouseLocation(event));\n            if (piechart.draggedPie) {\n                piechart.hoveredIndex = piechart.draggedPie.index;\n            }\n        }\n\n        function touchEnd() {\n\n            piechart.draggedPie = null;\n            piechart.draw();\n        }\n\n        function touchMove(event) {\n            var dragLocation = getMouseLocation(event);\n\n            if (!piechart.draggedPie) {\n                var hoveredTarget = piechart.getTarget(dragLocation);\n                if (hoveredTarget) {\n                    piechart.hoveredIndex = hoveredTarget.index;\n                    piechart.draw();\n                } else if (piechart.hoveredIndex != -1) {\n                    piechart.hoveredIndex = -1;\n                    piechart.draw();\n                }\n                return;\n            }\n\n            var draggedPie = piechart.draggedPie;\n\n            var dx = dragLocation.x - draggedPie.centerX;\n            var dy = dragLocation.y - draggedPie.centerY;\n\n            // Get angle of grabbed target from centre of pie\n            var newAngle = Math.atan2(dy, dx) - draggedPie.angleOffset;\n\n            piechart.shiftSelectedAngle(newAngle);\n            piechart.draw();\n        }\n\n        function getMouseLocation(evt) {\n            var rect = piechart.canvas.getBoundingClientRect();\n\n            if (evt.clientX) {\n                return {\n                    x: evt.clientX - rect.left,\n                    y: evt.clientY - rect.top\n                }\n            } else {\n                return {\n                    x: evt.originalEvent.targetTouches[0].clientX - rect.left,\n                    y: evt.originalEvent.targetTouches[0].clientY - rect.top\n                }\n            }\n        }\n\n        /*\n         * Generates angle data from proportions (array of objects with proportion, format\n         */\n        function generateDataFromProportions(proportions) {\n\n            // sum of proportions\n            var total = proportions.reduce(function (a, v) {\n                return a + v.proportion;\n            }, 0);\n\n            // begin at 0\n            var currentAngle = 0;\n\n            // use the proportions to reconstruct angles\n            return proportions.map(function (v, i) {\n                var arcSize = TAU * v.proportion / total;\n                var data = {\n                    angle: currentAngle,\n                    format: v.format,\n                    collapsed: arcSize <= 0\n                };\n                currentAngle = normaliseAngle(currentAngle + arcSize);\n                return data;\n            });\n\n        }\n\n    };\n\n    /*\n     * Move angle specified by index: i, by amount: angle in rads\n     */\n    DraggablePiechart.prototype.moveAngle = function (i, amount) {\n\n        if (this.data[i].collapsed && amount < 0) {\n            this.setCollapsed(i, false);\n            return;\n        }\n\n        var geometry = this.getGeometry();\n        this.draggedPie = {\n            index: i,\n            angleOffset: 0,\n            centerX: geometry.centerX,\n            centerY: geometry.centerY,\n            startingAngles: this.data.map(function (v) {\n                return v.angle;\n            }),\n            collapsed: this.data.map(function (v) {\n                return v.collapsed;\n            }),\n            angleDragDistance: 0\n        };\n\n        this.shiftSelectedAngle(this.data[i].angle + amount);\n        this.draggedPie = null;\n        this.draw();\n    };\n\n    /*\n     * Gets percentage of indexed slice\n     */\n    DraggablePiechart.prototype.getSliceSizePercentage = function (index) {\n        var visibleSegments = this.getVisibleSegments();\n\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n            if (visibleSegments[i].index == index) {\n                return 100 * visibleSegments[i].arcSize / TAU;\n            }\n        }\n        return 0;\n    };\n\n    /*\n     * Gets all percentages for each slice\n     */\n    DraggablePiechart.prototype.getAllSliceSizePercentages = function () {\n        var visibleSegments = this.getVisibleSegments();\n        var percentages = [];\n        for (var i = 0; i < this.data.length; i += 1) {\n\n            if (this.data[i].collapsed) {\n                percentages[i] = 0;\n            } else {\n                for (var j = 0; j < visibleSegments.length; j += 1) {\n                    if (visibleSegments[j].index == i) {\n                        percentages[i] = 100 * visibleSegments[j].arcSize / TAU;\n                    }\n                }\n            }\n\n        }\n\n        return percentages;\n    };\n\n    /*\n     * Gets the geometry of the pie chart in the canvas\n     */\n    DraggablePiechart.prototype.getGeometry = function () {\n        var centerX = Math.floor(this.canvas.width / 2);\n        var centerY = Math.floor(this.canvas.height / 2);\n        return {\n            centerX: centerX,\n            centerY: centerY,\n            radius: Math.min(centerX, centerY) * this.radius\n        }\n    };\n\n    /*\n     * Returns a segment to drag if given a close enough location\n     */\n    DraggablePiechart.prototype.getTarget = function (targetLocation) {\n\n        var geometry = this.getGeometry();\n        var startingAngles = [];\n        var collapsed = [];\n\n        var closest = {\n            index: -1,\n            distance: 9999999,\n            angle: null\n        };\n\n        for (var i = 0; i < this.data.length; i += 1) {\n\n            startingAngles.push(this.data[i].angle);\n            collapsed.push(this.data[i].collapsed);\n\n            if (this.data[i].collapsed) {\n                continue;\n            }\n\n\n            var dx = targetLocation.x - geometry.centerX;\n            var dy = targetLocation.y - geometry.centerY;\n            var trueGrabbedAngle = Math.atan2(dy, dx);\n\n            var distance = Math.abs(smallestSignedAngleBetween(trueGrabbedAngle, this.data[i].angle));\n\n            if (distance < closest.distance) {\n                closest.index = i;\n                closest.distance = distance;\n                closest.angle = trueGrabbedAngle;\n            }\n        }\n\n        if (closest.distance < 0.1) {\n\n            return {\n                index: closest.index,\n                angleOffset: smallestSignedAngleBetween(closest.angle, startingAngles[closest.index]),\n                centerX: geometry.centerX,\n                centerY: geometry.centerY,\n                startingAngles: startingAngles,\n                collapsed: collapsed,\n                angleDragDistance: 0\n            }\n        } else {\n            return null;\n        }\n    };\n\n    /*\n     * Sets segments collapsed or uncollapsed\n     */\n    DraggablePiechart.prototype.setCollapsed = function (index, collapsed) {\n\n        // Flag to set position of previously collapsed to new location\n        var setNewPos = this.data[index].collapsed && !collapsed;\n\n        this.data[index].collapsed = collapsed;\n\n        var visibleSegments = this.getVisibleSegments();\n\n        // Shift other segments along to make space if necessary\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n\n            // Start at this segment\n            if (visibleSegments[i].index == index) {\n\n                //Set new position\n                if (setNewPos) {\n                    var nextSegment = visibleSegments[mod(i + 1, visibleSegments.length)];\n                    this.data[index].angle = nextSegment.angle - this.minAngle;\n                }\n\n                for (var j = 0; j < (visibleSegments.length - 1); j += 1) {\n                    var currentSegment = visibleSegments[mod(1 + i - j, visibleSegments.length)];\n                    var nextAlongSegment = visibleSegments[mod(i - j, visibleSegments.length)];\n\n                    var angleBetween = Math.abs(smallestSignedAngleBetween(this.data[currentSegment.index].angle, this.data[nextAlongSegment.index].angle));\n\n                    if (angleBetween < this.minAngle) {\n                        this.data[nextAlongSegment.index].angle = normaliseAngle(this.data[currentSegment.index].angle - this.minAngle);\n                    }\n\n                }\n                break;\n            }\n        }\n\n        this.draw();\n    };\n\n    /*\n     * Returns visible segments\n     */\n    DraggablePiechart.prototype.getVisibleSegments = function () {\n\n        var piechart = this;\n        // Collect data for visible segments\n        var visibleSegments = [];\n        for (var i = 0; i < piechart.data.length; i += 1) {\n\n            if (!piechart.data[i].collapsed) {\n                var startingAngle = piechart.data[i].angle;\n\n                // Get arcSize\n                var foundNextAngle = false;\n                for (var j = 1; j < piechart.data.length; j += 1) {\n                    var nextAngleIndex = (i + j) % piechart.data.length;\n\n                    if (!piechart.data[nextAngleIndex].collapsed) {\n                        var arcSize = piechart.data[nextAngleIndex].angle - startingAngle;\n                        if (arcSize <= 0) {\n                            arcSize += TAU;\n                        }\n\n                        visibleSegments.push({\n                            arcSize: arcSize,\n                            angle: startingAngle,\n                            format: piechart.data[i].format,\n                            index: i\n                        });\n\n                        foundNextAngle = true;\n                        break;\n                    }\n                }\n\n                // Only one segment\n                if (!foundNextAngle) {\n                    visibleSegments.push({\n                        arcSize: TAU,\n                        angle: startingAngle,\n                        format: piechart.data[i].format,\n                        index: i\n                    });\n                    break;\n                }\n            }\n\n        }\n        return visibleSegments;\n    };\n\n    /*\n     * Returns invisible segments\n     */\n    DraggablePiechart.prototype.getInvisibleSegments = function () {\n        var piechart = this;\n        // Collect data for visible segments\n        var invisibleSegments = [];\n        for (var i = 0; i < piechart.data.length; i += 1) {\n            if (piechart.data[i].collapsed) {\n                invisibleSegments.push({\n                    index: i,\n                    format: piechart.data[i].format\n                })\n            }\n        }\n\n        return invisibleSegments;\n    };\n\n    /*\n     * Draws the piechart\n     */\n    DraggablePiechart.prototype.draw = function () {\n        var piechart = this;\n        var context = piechart.context;\n        var canvas = piechart.canvas;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        var geometry = this.getGeometry();\n\n        var visibleSegments = this.getVisibleSegments();\n\n        // Flags to get arc sizes and index of largest arc, for drawing order\n        var largestArcSize = 0;\n        var indexLargestArcSize = -1;\n\n        // Get the largeset arcsize\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n            if (visibleSegments[i].arcSize > largestArcSize) {\n                largestArcSize = visibleSegments[i].arcSize;\n                indexLargestArcSize = i;\n            }\n        }\n\n\n        // Need to draw in correct order\n        for (i = 0; i < visibleSegments.length; i += 1) {\n\n            // Start with one *after* largest\n            var index = mod(i + indexLargestArcSize + 1, visibleSegments.length);\n            piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, visibleSegments[index].angle, visibleSegments[index].arcSize, visibleSegments[index].format, false);\n        }\n\n        // Now draw invisible segments\n        var invisibleSegments = this.getInvisibleSegments();\n        for (i = 0; i < invisibleSegments.length; i += 1) {\n            piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, 0, 0, invisibleSegments[i].format, true);\n        }\n\n        // Finally draw drag nodes on top (order not important)\n        for (i = 0; i < visibleSegments.length; i += 1) {\n            var location = polarToCartesian(visibleSegments[i].angle, geometry.radius);\n            piechart.drawNode(context, piechart, location.x, location.y, geometry.centerX, geometry.centerY, i == piechart.hoveredIndex);\n        }\n\n        piechart.onchange(piechart);\n\n    };\n\n    /*\n     * *INTERNAL USE ONLY*\n     * Moves the selected angle to a new angle\n     */\n    DraggablePiechart.prototype.shiftSelectedAngle = function (newAngle) {\n        var piechart = this;\n        if (!piechart.draggedPie) {\n            return;\n        }\n        var draggedPie = piechart.draggedPie;\n\n\n        // Get starting angle of the target\n        var startingAngle = draggedPie.startingAngles[draggedPie.index];\n\n        // Get previous angle of the target\n        var previousAngle = piechart.data[draggedPie.index].angle;\n\n        // Get diff from grabbed target start (as -pi to +pi)\n        var angleDragDistance = smallestSignedAngleBetween(newAngle, startingAngle);\n\n        // Get previous diff\n        var previousDragDistance = draggedPie.angleDragDistance;\n\n        // Determines whether we go clockwise or anticlockwise\n        var rotationDirection = previousDragDistance > 0 ? 1 : -1;\n\n\n        // Reverse the direction if we have done over 180 in either direction\n        var sameDirection = previousDragDistance > 0 == angleDragDistance > 0;\n        var greaterThanHalf = Math.abs(previousDragDistance - angleDragDistance) > Math.PI;\n\n\n        if (greaterThanHalf && !sameDirection) {\n            // Reverse the angle\n            angleDragDistance = (TAU - Math.abs(angleDragDistance)) * rotationDirection;\n        } else {\n            rotationDirection = angleDragDistance > 0 ? 1 : -1;\n        }\n\n        draggedPie.angleDragDistance = angleDragDistance;\n\n\n        // Set the new angle:\n        piechart.data[draggedPie.index].angle = normaliseAngle(startingAngle + angleDragDistance);\n\n        // Reset Collapse\n        piechart.data[draggedPie.index].collapsed = draggedPie.collapsed[draggedPie.index];\n\n        // Search other angles\n        var shifting = true;\n        var collapsed = false;\n        var minAngle = piechart.minAngle;\n        var numberOfAnglesShifted = 0;\n\n        for (var i = 1; i < piechart.data.length; i += 1) {\n\n            // Index to test each slice in order\n            var index = mod(draggedPie.index + (i * rotationDirection), piechart.data.length);\n\n            // Get angle from target start to this angle\n            var startingAngleToNonDragged = smallestSignedAngleBetween(draggedPie.startingAngles[index], startingAngle);\n\n            // If angle is in the wrong direction then it should actually be OVER 180\n            if (startingAngleToNonDragged * rotationDirection < 0) {\n                startingAngleToNonDragged = ((startingAngleToNonDragged * rotationDirection) + TAU) * rotationDirection;\n            }\n\n            if (piechart.collapsing) {\n                // *Collapsing behaviour* when smallest angle encountered\n\n                // Reset collapse\n                piechart.data[index].collapsed = draggedPie.collapsed[index];\n\n                var checkForSnap = !collapsed && !piechart.data[index].collapsed;\n\n                // Snap node to collapse, and prevent going any further\n                if (checkForSnap && startingAngleToNonDragged > 0 && angleDragDistance > (startingAngleToNonDragged - minAngle)) {\n                    piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n                    piechart.data[draggedPie.index].collapsed = true;\n                    collapsed = true;\n                } else if (checkForSnap && startingAngleToNonDragged < 0 && angleDragDistance < (startingAngleToNonDragged + minAngle)) {\n                    piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n                    piechart.data[index].collapsed = true;\n                    collapsed = true;\n                } else {\n                    piechart.data[index].angle = draggedPie.startingAngles[index];\n\n                }\n            } else {\n                // *Shifting behaviour* when smallest angle encountered\n\n                // Shift all other angles along\n                var shift = (numberOfAnglesShifted + 1) * minAngle;\n\n                if (shifting && startingAngleToNonDragged > 0 && angleDragDistance > (startingAngleToNonDragged - shift)) {\n                    piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] + (angleDragDistance - startingAngleToNonDragged) + shift);\n                    numberOfAnglesShifted += 1;\n                } else if (shifting && startingAngleToNonDragged < 0 && angleDragDistance < (startingAngleToNonDragged + shift)) {\n                    piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] - (startingAngleToNonDragged - angleDragDistance) - shift);\n                    numberOfAnglesShifted += 1;\n                } else {\n                    shifting = false;\n                    piechart.data[index].angle = draggedPie.startingAngles[index];\n                }\n            }\n\n            //console.log(JSON.stringify(piechart.data));\n\n        }\n\n\n    };\n\n    DraggablePiechart.prototype.defaults = {\n\n        onchange: function (piechart) {\n        },\n        radius: 0.9,\n        data: [\n            {angle: -2, format: {color: \"#2665da\", label: 'Walking'}, collapsed: false},\n            {angle: -1, format: {color: \"#6dd020\", label: 'Programming'}, collapsed: false},\n            {angle: 0, format: {color: \"#f9df18\", label: 'Chess'}, collapsed: false},\n            {angle: 1, format: {color: \"#d42a00\", label: 'Eating'}, collapsed: false},\n            {angle: 2, format: {color: \"#e96400\", label: 'Sleeping'}, collapsed: false}],\n        collapsing: false,\n        minAngle: 0.1,\n\n        drawSegment: function (context, piechart, centerX, centerY, radius, startingAngle, arcSize, format, collapsed) {\n\n            if (collapsed) {\n                return;\n            }\n\n            // Draw coloured segment\n            context.save();\n            var endingAngle = startingAngle + arcSize;\n            context.beginPath();\n            context.moveTo(centerX, centerY);\n            context.arc(centerX, centerY, radius,\n                startingAngle, endingAngle, false);\n            context.closePath();\n\n            context.fillStyle = format.color;\n            context.fill();\n            context.restore();\n\n            // Draw label on top\n            context.save();\n            context.translate(centerX, centerY);\n            context.rotate(startingAngle);\n\n            var fontSize = Math.floor(context.canvas.height / 25);\n            var dx = radius - fontSize;\n            var dy = centerY / 10;\n\n            context.textAlign = \"right\";\n            context.font = fontSize + \"pt Helvetica\";\n            context.fillText(format.label, dx, dy);\n            context.restore();\n        },\n\n        drawNode: function (context, piechart, x, y, centerX, centerY, hover) {\n\n            context.save();\n            context.translate(centerX, centerY);\n            context.fillStyle = '#DDDDDD';\n\n            var rad = hover ? 7 : 5;\n            context.beginPath();\n            context.arc(x, y, rad, 0, TAU, true);\n            context.fill();\n            context.stroke();\n            context.restore();\n        }\n    };\n\n    window.DraggablePiechart = DraggablePiechart;\n\n    /*\n     * Utilities + Constants\n     */\n\n    var TAU = Math.PI * 2;\n\n    function degreesToRadians(degrees) {\n        return (degrees * Math.PI) / 180;\n    }\n\n    function smallestSignedAngleBetween(target, source) {\n        return Math.atan2(Math.sin(target - source), Math.cos(target - source));\n    }\n\n    function mod(n, m) {\n        return ((n % m) + m) % m;\n    }\n\n    function is_touch_device() {\n        return 'ontouchstart' in window        // works on most browsers\n            || navigator.maxTouchPoints;       // works on IE10/11 and Surface\n    }\n\n    function normaliseAngle(angle) {\n        return mod(angle + Math.PI, TAU) - Math.PI;\n    }\n\n    function polarToCartesian(angle, radius) {\n        return {\n            x: radius * Math.cos(angle),\n            y: radius * Math.sin(angle)\n        }\n    }\n\n})(jQuery);\n\n"]},"metadata":{},"sourceType":"module"}