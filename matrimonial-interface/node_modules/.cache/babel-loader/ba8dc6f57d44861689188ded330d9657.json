{"ast":null,"code":"/**\n * Created by james on 23/02/2017.\n */\n(function () {\n  var extend = function extend(out) {\n    out = out || {};\n\n    for (var i = 1; i < arguments.length; i++) {\n      if (!arguments[i]) continue;\n\n      for (var key in arguments[i]) {\n        if (arguments[i].hasOwnProperty(key)) out[key] = arguments[i][key];\n      }\n    }\n\n    return out;\n  };\n\n  var DraggablePiechart = function DraggablePiechart(setup) {\n    var piechart = this;\n    setup = extend({}, this.defaults, setup);\n    this.canvas = setup.canvas;\n    this.context = setup.canvas.getContext(\"2d\");\n\n    if (!this.context) {\n      console.log('Error: DraggablePiechart needs an html5 canvas.');\n      return;\n    }\n\n    if (setup.proportions) {\n      this.data = generateDataFromProportions(setup.proportions);\n    } else if (setup.data) {\n      this.data = setup.data;\n    }\n\n    this.draggedPie = null;\n    this.hoveredIndex = -1;\n    this.radius = setup.radius;\n    this.collapsing = setup.collapsing;\n    this.minAngle = setup.minAngle;\n    this.drawSegment = setup.drawSegment;\n    this.drawNode = setup.drawNode;\n    this.onchange = setup.onchange; // Bind appropriate events\n\n    this.canvas.addEventListener('touchstart', function (e) {\n      touchStart(e);\n      e.preventDefault();\n    });\n    this.canvas.addEventListener('touchmove', function (e) {\n      touchMove(e);\n      e.preventDefault();\n    });\n    document.addEventListener('touchend', function (e) {\n      touchEnd(e);\n    });\n    this.canvas.addEventListener('mousedown', touchStart);\n    this.canvas.addEventListener('mousemove', touchMove);\n    document.addEventListener('mouseup', touchEnd);\n    this.draw();\n\n    function touchStart(event) {\n      piechart.draggedPie = piechart.getTarget(getMouseLocation(event));\n\n      if (piechart.draggedPie) {\n        piechart.hoveredIndex = piechart.draggedPie.index;\n      }\n    }\n\n    function touchEnd() {\n      if (piechart.draggedPie) {\n        piechart.draggedPie = null;\n        piechart.draw();\n      }\n    }\n\n    function touchMove(event) {\n      var dragLocation = getMouseLocation(event);\n\n      if (!piechart.draggedPie) {\n        var hoveredTarget = piechart.getTarget(dragLocation);\n\n        if (hoveredTarget) {\n          piechart.hoveredIndex = hoveredTarget.index;\n          piechart.draw();\n        } else if (piechart.hoveredIndex != -1) {\n          piechart.hoveredIndex = -1;\n          piechart.draw();\n        }\n\n        return;\n      }\n\n      var draggedPie = piechart.draggedPie;\n      var dx = dragLocation.x - draggedPie.centerX;\n      var dy = dragLocation.y - draggedPie.centerY; // Get angle of grabbed target from centre of pie\n\n      var newAngle = Math.atan2(dy, dx) - draggedPie.angleOffset;\n      piechart.shiftSelectedAngle(newAngle);\n      piechart.draw();\n    }\n\n    function getMouseLocation(evt) {\n      var rect = piechart.canvas.getBoundingClientRect();\n\n      if (evt.clientX) {\n        return {\n          x: evt.clientX - rect.left,\n          y: evt.clientY - rect.top\n        };\n      } else {\n        return {\n          x: evt.targetTouches[0].clientX - rect.left,\n          y: evt.targetTouches[0].clientY - rect.top\n        };\n      }\n    }\n    /*\n     * Generates angle data from proportions (array of objects with proportion, format\n     */\n\n\n    function generateDataFromProportions(proportions) {\n      // sum of proportions\n      var total = proportions.reduce(function (a, v) {\n        return a + v.proportion;\n      }, 0); // begin at 0\n\n      var currentAngle = 0; // use the proportions to reconstruct angles\n\n      return proportions.map(function (v, i) {\n        var arcSize = TAU * v.proportion / total;\n        var data = {\n          angle: currentAngle,\n          format: v.format,\n          collapsed: arcSize <= 0\n        };\n        currentAngle = normaliseAngle(currentAngle + arcSize);\n        return data;\n      });\n    }\n  };\n  /*\n   * Move angle specified by index: i, by amount: angle in rads\n   */\n\n\n  DraggablePiechart.prototype.moveAngle = function (i, amount) {\n    if (this.data[i].collapsed && amount < 0) {\n      this.setCollapsed(i, false);\n      return;\n    }\n\n    var geometry = this.getGeometry();\n    this.draggedPie = {\n      index: i,\n      angleOffset: 0,\n      centerX: geometry.centerX,\n      centerY: geometry.centerY,\n      startingAngles: this.data.map(function (v) {\n        return v.angle;\n      }),\n      collapsed: this.data.map(function (v) {\n        return v.collapsed;\n      }),\n      angleDragDistance: 0\n    };\n    this.shiftSelectedAngle(this.data[i].angle + amount);\n    this.draggedPie = null;\n    this.draw();\n  };\n  /*\n   * Gets percentage of indexed slice\n   */\n\n\n  DraggablePiechart.prototype.getSliceSizePercentage = function (index) {\n    var visibleSegments = this.getVisibleSegments();\n\n    for (var i = 0; i < visibleSegments.length; i += 1) {\n      if (visibleSegments[i].index == index) {\n        return 100 * visibleSegments[i].arcSize / TAU;\n      }\n    }\n\n    return 0;\n  };\n  /*\n   * Gets all percentages for each slice\n   */\n\n\n  DraggablePiechart.prototype.getAllSliceSizePercentages = function () {\n    var visibleSegments = this.getVisibleSegments();\n    var percentages = [];\n\n    for (var i = 0; i < this.data.length; i += 1) {\n      if (this.data[i].collapsed) {\n        percentages[i] = 0;\n      } else {\n        for (var j = 0; j < visibleSegments.length; j += 1) {\n          if (visibleSegments[j].index == i) {\n            percentages[i] = 100 * visibleSegments[j].arcSize / TAU;\n          }\n        }\n      }\n    }\n\n    return percentages;\n  };\n  /*\n   * Gets the geometry of the pie chart in the canvas\n   */\n\n\n  DraggablePiechart.prototype.getGeometry = function () {\n    var centerX = Math.floor(this.canvas.width / 2);\n    var centerY = Math.floor(this.canvas.height / 2);\n    return {\n      centerX: centerX,\n      centerY: centerY,\n      radius: Math.min(centerX, centerY) * this.radius\n    };\n  };\n  /*\n   * Returns a segment to drag if given a close enough location\n   */\n\n\n  DraggablePiechart.prototype.getTarget = function (targetLocation) {\n    var geometry = this.getGeometry();\n    var startingAngles = [];\n    var collapsed = [];\n    var closest = {\n      index: -1,\n      distance: 9999999,\n      angle: null\n    };\n\n    for (var i = 0; i < this.data.length; i += 1) {\n      startingAngles.push(this.data[i].angle);\n      collapsed.push(this.data[i].collapsed);\n\n      if (this.data[i].collapsed) {\n        continue;\n      }\n\n      var dx = targetLocation.x - geometry.centerX;\n      var dy = targetLocation.y - geometry.centerY;\n      var trueGrabbedAngle = Math.atan2(dy, dx);\n      var distance = Math.abs(smallestSignedAngleBetween(trueGrabbedAngle, this.data[i].angle));\n\n      if (distance < closest.distance) {\n        closest.index = i;\n        closest.distance = distance;\n        closest.angle = trueGrabbedAngle;\n      }\n    }\n\n    if (closest.distance < 0.1) {\n      return {\n        index: closest.index,\n        angleOffset: smallestSignedAngleBetween(closest.angle, startingAngles[closest.index]),\n        centerX: geometry.centerX,\n        centerY: geometry.centerY,\n        startingAngles: startingAngles,\n        collapsed: collapsed,\n        angleDragDistance: 0\n      };\n    } else {\n      return null;\n    }\n  };\n  /*\n   * Sets segments collapsed or uncollapsed\n   */\n\n\n  DraggablePiechart.prototype.setCollapsed = function (index, collapsed) {\n    // Flag to set position of previously collapsed to new location\n    var setNewPos = this.data[index].collapsed && !collapsed;\n    this.data[index].collapsed = collapsed;\n    var visibleSegments = this.getVisibleSegments(); // Shift other segments along to make space if necessary\n\n    for (var i = 0; i < visibleSegments.length; i += 1) {\n      // Start at this segment\n      if (visibleSegments[i].index == index) {\n        //Set new position\n        if (setNewPos) {\n          var nextSegment = visibleSegments[mod(i + 1, visibleSegments.length)];\n          this.data[index].angle = nextSegment.angle - this.minAngle;\n        }\n\n        for (var j = 0; j < visibleSegments.length - 1; j += 1) {\n          var currentSegment = visibleSegments[mod(1 + i - j, visibleSegments.length)];\n          var nextAlongSegment = visibleSegments[mod(i - j, visibleSegments.length)];\n          var angleBetween = Math.abs(smallestSignedAngleBetween(this.data[currentSegment.index].angle, this.data[nextAlongSegment.index].angle));\n\n          if (angleBetween < this.minAngle) {\n            this.data[nextAlongSegment.index].angle = normaliseAngle(this.data[currentSegment.index].angle - this.minAngle);\n          }\n        }\n\n        break;\n      }\n    }\n\n    this.draw();\n  };\n  /*\n   * Returns visible segments\n   */\n\n\n  DraggablePiechart.prototype.getVisibleSegments = function () {\n    var piechart = this; // Collect data for visible segments\n\n    var visibleSegments = [];\n\n    for (var i = 0; i < piechart.data.length; i += 1) {\n      if (!piechart.data[i].collapsed) {\n        var startingAngle = piechart.data[i].angle; // Get arcSize\n\n        var foundNextAngle = false;\n\n        for (var j = 1; j < piechart.data.length; j += 1) {\n          var nextAngleIndex = (i + j) % piechart.data.length;\n\n          if (!piechart.data[nextAngleIndex].collapsed) {\n            var arcSize = piechart.data[nextAngleIndex].angle - startingAngle;\n\n            if (arcSize <= 0) {\n              arcSize += TAU;\n            }\n\n            visibleSegments.push({\n              arcSize: arcSize,\n              angle: startingAngle,\n              format: piechart.data[i].format,\n              index: i\n            });\n            foundNextAngle = true;\n            break;\n          }\n        } // Only one segment\n\n\n        if (!foundNextAngle) {\n          visibleSegments.push({\n            arcSize: TAU,\n            angle: startingAngle,\n            format: piechart.data[i].format,\n            index: i\n          });\n          break;\n        }\n      }\n    }\n\n    return visibleSegments;\n  };\n  /*\n   * Returns invisible segments\n   */\n\n\n  DraggablePiechart.prototype.getInvisibleSegments = function () {\n    var piechart = this; // Collect data for visible segments\n\n    var invisibleSegments = [];\n\n    for (var i = 0; i < piechart.data.length; i += 1) {\n      if (piechart.data[i].collapsed) {\n        invisibleSegments.push({\n          index: i,\n          format: piechart.data[i].format\n        });\n      }\n    }\n\n    return invisibleSegments;\n  };\n  /*\n   * Draws the piechart\n   */\n\n\n  DraggablePiechart.prototype.draw = function () {\n    var piechart = this;\n    var context = piechart.context;\n    var canvas = piechart.canvas;\n    context.clearRect(0, 0, canvas.width, canvas.height);\n    var geometry = this.getGeometry();\n    var visibleSegments = this.getVisibleSegments(); // Flags to get arc sizes and index of largest arc, for drawing order\n\n    var largestArcSize = 0;\n    var indexLargestArcSize = -1; // Get the largeset arcsize\n\n    for (var i = 0; i < visibleSegments.length; i += 1) {\n      if (visibleSegments[i].arcSize > largestArcSize) {\n        largestArcSize = visibleSegments[i].arcSize;\n        indexLargestArcSize = i;\n      }\n    } // Need to draw in correct order\n\n\n    for (i = 0; i < visibleSegments.length; i += 1) {\n      // Start with one *after* largest\n      var index = mod(i + indexLargestArcSize + 1, visibleSegments.length);\n      piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, visibleSegments[index].angle, visibleSegments[index].arcSize, visibleSegments[index].format, false);\n    } // Now draw invisible segments\n\n\n    var invisibleSegments = this.getInvisibleSegments();\n\n    for (i = 0; i < invisibleSegments.length; i += 1) {\n      piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, 0, 0, invisibleSegments[i].format, true);\n    } // Finally draw drag nodes on top (order not important)\n\n\n    for (i = 0; i < visibleSegments.length; i += 1) {\n      var location = polarToCartesian(visibleSegments[i].angle, geometry.radius);\n      piechart.drawNode(context, piechart, location.x, location.y, geometry.centerX, geometry.centerY, i == piechart.hoveredIndex);\n    }\n\n    piechart.onchange(piechart);\n  };\n  /*\n   * *INTERNAL USE ONLY*\n   * Moves the selected angle to a new angle\n   */\n\n\n  DraggablePiechart.prototype.shiftSelectedAngle = function (newAngle) {\n    var piechart = this;\n\n    if (!piechart.draggedPie) {\n      return;\n    }\n\n    var draggedPie = piechart.draggedPie; // Get starting angle of the target\n\n    var startingAngle = draggedPie.startingAngles[draggedPie.index]; // Get previous angle of the target\n\n    var previousAngle = piechart.data[draggedPie.index].angle; // Get diff from grabbed target start (as -pi to +pi)\n\n    var angleDragDistance = smallestSignedAngleBetween(newAngle, startingAngle); // Get previous diff\n\n    var previousDragDistance = draggedPie.angleDragDistance; // Determines whether we go clockwise or anticlockwise\n\n    var rotationDirection = previousDragDistance > 0 ? 1 : -1; // Reverse the direction if we have done over 180 in either direction\n\n    var sameDirection = previousDragDistance > 0 == angleDragDistance > 0;\n    var greaterThanHalf = Math.abs(previousDragDistance - angleDragDistance) > Math.PI;\n\n    if (greaterThanHalf && !sameDirection) {\n      // Reverse the angle\n      angleDragDistance = (TAU - Math.abs(angleDragDistance)) * rotationDirection;\n    } else {\n      rotationDirection = angleDragDistance > 0 ? 1 : -1;\n    }\n\n    draggedPie.angleDragDistance = angleDragDistance; // Set the new angle:\n\n    piechart.data[draggedPie.index].angle = normaliseAngle(startingAngle + angleDragDistance); // Reset Collapse\n\n    piechart.data[draggedPie.index].collapsed = draggedPie.collapsed[draggedPie.index]; // Search other angles\n\n    var shifting = true;\n    var collapsed = false;\n    var minAngle = piechart.minAngle;\n    var numberOfAnglesShifted = 0;\n\n    for (var i = 1; i < piechart.data.length; i += 1) {\n      // Index to test each slice in order\n      var index = mod(parseInt(draggedPie.index) + i * rotationDirection, piechart.data.length); // Get angle from target start to this angle\n\n      var startingAngleToNonDragged = smallestSignedAngleBetween(draggedPie.startingAngles[index], startingAngle); // If angle is in the wrong direction then it should actually be OVER 180\n\n      if (startingAngleToNonDragged * rotationDirection < 0) {\n        startingAngleToNonDragged = (startingAngleToNonDragged * rotationDirection + TAU) * rotationDirection;\n      }\n\n      if (piechart.collapsing) {\n        // *Collapsing behaviour* when smallest angle encountered\n        // Reset collapse\n        piechart.data[index].collapsed = draggedPie.collapsed[index];\n        var checkForSnap = !collapsed && !piechart.data[index].collapsed; // Snap node to collapse, and prevent going any further\n\n        if (checkForSnap && startingAngleToNonDragged > 0 && angleDragDistance > startingAngleToNonDragged - minAngle) {\n          piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n          piechart.data[draggedPie.index].collapsed = true;\n          collapsed = true;\n        } else if (checkForSnap && startingAngleToNonDragged < 0 && angleDragDistance < startingAngleToNonDragged + minAngle) {\n          piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n          piechart.data[index].collapsed = true;\n          collapsed = true;\n        } else {\n          piechart.data[index].angle = draggedPie.startingAngles[index];\n        }\n      } else {\n        // *Shifting behaviour* when smallest angle encountered\n        // Shift all other angles along\n        var shift = (numberOfAnglesShifted + 1) * minAngle;\n\n        if (shifting && startingAngleToNonDragged > 0 && angleDragDistance > startingAngleToNonDragged - shift) {\n          piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] + (angleDragDistance - startingAngleToNonDragged) + shift);\n          numberOfAnglesShifted += 1;\n        } else if (shifting && startingAngleToNonDragged < 0 && angleDragDistance < startingAngleToNonDragged + shift) {\n          piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] - (startingAngleToNonDragged - angleDragDistance) - shift);\n          numberOfAnglesShifted += 1;\n        } else {\n          shifting = false;\n          piechart.data[index].angle = draggedPie.startingAngles[index];\n        }\n      } //console.log(JSON.stringify(piechart.data));\n\n    }\n  };\n\n  DraggablePiechart.prototype.defaults = {\n    onchange: function onchange(piechart) {},\n    radius: 0.9,\n    data: [{\n      angle: -2,\n      format: {\n        color: \"#2665da\",\n        label: 'Walking'\n      },\n      collapsed: false\n    }, {\n      angle: -1,\n      format: {\n        color: \"#6dd020\",\n        label: 'Programming'\n      },\n      collapsed: false\n    }, {\n      angle: 0,\n      format: {\n        color: \"#f9df18\",\n        label: 'Chess'\n      },\n      collapsed: false\n    }, {\n      angle: 1,\n      format: {\n        color: \"#d42a00\",\n        label: 'Eating'\n      },\n      collapsed: false\n    }, {\n      angle: 2,\n      format: {\n        color: \"#e96400\",\n        label: 'Sleeping'\n      },\n      collapsed: false\n    }],\n    collapsing: false,\n    minAngle: 0.1,\n    drawSegment: function drawSegment(context, piechart, centerX, centerY, radius, startingAngle, arcSize, format, collapsed) {\n      if (collapsed) {\n        return;\n      } // Draw coloured segment\n\n\n      context.save();\n      var endingAngle = startingAngle + arcSize;\n      context.beginPath();\n      context.moveTo(centerX, centerY);\n      context.arc(centerX, centerY, radius, startingAngle, endingAngle, false);\n      context.closePath();\n      context.fillStyle = format.color;\n      context.fill();\n      context.restore(); // Draw label on top\n\n      context.save();\n      context.translate(centerX, centerY);\n      context.rotate(startingAngle);\n      var fontSize = Math.floor(context.canvas.height / 25);\n      var dx = radius - fontSize;\n      var dy = centerY / 10;\n      context.textAlign = \"right\";\n      context.font = fontSize + \"pt Helvetica\";\n      context.fillText(format.label, dx, dy);\n      context.restore();\n    },\n    drawNode: function drawNode(context, piechart, x, y, centerX, centerY, hover) {\n      context.save();\n      context.translate(centerX, centerY);\n      context.fillStyle = '#DDDDDD';\n      var rad = hover ? 7 : 5;\n      context.beginPath();\n      context.arc(x, y, rad, 0, TAU, true);\n      context.fill();\n      context.stroke();\n      context.restore();\n    }\n  };\n  window.DraggablePiechart = DraggablePiechart;\n  /*\n   * Utilities + Constants\n   */\n\n  var TAU = Math.PI * 2;\n\n  function degreesToRadians(degrees) {\n    return degrees * Math.PI / 180;\n  }\n\n  function smallestSignedAngleBetween(target, source) {\n    return Math.atan2(Math.sin(target - source), Math.cos(target - source));\n  }\n\n  function mod(n, m) {\n    return (n % m + m) % m;\n  }\n\n  function normaliseAngle(angle) {\n    return mod(angle + Math.PI, TAU) - Math.PI;\n  }\n\n  function polarToCartesian(angle, radius) {\n    return {\n      x: radius * Math.cos(angle),\n      y: radius * Math.sin(angle)\n    };\n  }\n})();","map":{"version":3,"sources":["/Users/jvlyndark/Documents/Matrimonial Interfaces/matrimonial-interface/matrimonial-interface/matrimonial-interface/app/javascript/packs/draggable-piechart.js"],"names":["extend","out","i","arguments","length","key","hasOwnProperty","DraggablePiechart","setup","piechart","defaults","canvas","context","getContext","console","log","proportions","data","generateDataFromProportions","draggedPie","hoveredIndex","radius","collapsing","minAngle","drawSegment","drawNode","onchange","addEventListener","e","touchStart","preventDefault","touchMove","document","touchEnd","draw","event","getTarget","getMouseLocation","index","dragLocation","hoveredTarget","dx","x","centerX","dy","y","centerY","newAngle","Math","atan2","angleOffset","shiftSelectedAngle","evt","rect","getBoundingClientRect","clientX","left","clientY","top","targetTouches","total","reduce","a","v","proportion","currentAngle","map","arcSize","TAU","angle","format","collapsed","normaliseAngle","prototype","moveAngle","amount","setCollapsed","geometry","getGeometry","startingAngles","angleDragDistance","getSliceSizePercentage","visibleSegments","getVisibleSegments","getAllSliceSizePercentages","percentages","j","floor","width","height","min","targetLocation","closest","distance","push","trueGrabbedAngle","abs","smallestSignedAngleBetween","setNewPos","nextSegment","mod","currentSegment","nextAlongSegment","angleBetween","startingAngle","foundNextAngle","nextAngleIndex","getInvisibleSegments","invisibleSegments","clearRect","largestArcSize","indexLargestArcSize","location","polarToCartesian","previousAngle","previousDragDistance","rotationDirection","sameDirection","greaterThanHalf","PI","shifting","numberOfAnglesShifted","parseInt","startingAngleToNonDragged","checkForSnap","shift","color","label","save","endingAngle","beginPath","moveTo","arc","closePath","fillStyle","fill","restore","translate","rotate","fontSize","textAlign","font","fillText","hover","rad","stroke","window","degreesToRadians","degrees","target","source","sin","cos","n","m"],"mappings":"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","sourcesContent":["/**\n * Created by james on 23/02/2017.\n */\n\n(function () {\n\n    var extend = function (out) {\n        out = out || {};\n\n        for (var i = 1; i < arguments.length; i++) {\n            if (!arguments[i])\n                continue;\n\n            for (var key in arguments[i]) {\n                if (arguments[i].hasOwnProperty(key))\n                    out[key] = arguments[i][key];\n            }\n        }\n\n        return out;\n    };\n\n    var DraggablePiechart = function (setup) {\n\n        var piechart = this;\n\n        setup = extend({}, this.defaults, setup);\n\n        this.canvas = setup.canvas;\n        this.context = setup.canvas.getContext(\"2d\");\n\n        if (!this.context) {\n            console.log('Error: DraggablePiechart needs an html5 canvas.');\n            return;\n        }\n\n        if (setup.proportions) {\n            this.data = generateDataFromProportions(setup.proportions);\n        } else if (setup.data) {\n            this.data = setup.data;\n        }\n\n        this.draggedPie = null;\n        this.hoveredIndex = -1;\n        this.radius = setup.radius;\n        this.collapsing = setup.collapsing;\n        this.minAngle = setup.minAngle;\n        this.drawSegment = setup.drawSegment;\n        this.drawNode = setup.drawNode;\n        this.onchange = setup.onchange;\n\n\n        // Bind appropriate events\n\n        this.canvas.addEventListener('touchstart', function (e) {\n            touchStart(e);\n            e.preventDefault();\n        });\n        this.canvas.addEventListener('touchmove', function (e) {\n            touchMove(e);\n            e.preventDefault();\n        });\n        document.addEventListener('touchend', function (e) {\n            touchEnd(e);\n        });\n\n        this.canvas.addEventListener('mousedown', touchStart);\n        this.canvas.addEventListener('mousemove', touchMove);\n        document.addEventListener('mouseup', touchEnd);\n\n\n        this.draw();\n\n        function touchStart(event) {\n\n            piechart.draggedPie = piechart.getTarget(getMouseLocation(event));\n            if (piechart.draggedPie) {\n                piechart.hoveredIndex = piechart.draggedPie.index;\n            }\n        }\n\n        function touchEnd() {\n\n            if (piechart.draggedPie) {\n                piechart.draggedPie = null;\n                piechart.draw();\n            }\n        }\n\n        function touchMove(event) {\n            var dragLocation = getMouseLocation(event);\n\n            if (!piechart.draggedPie) {\n                var hoveredTarget = piechart.getTarget(dragLocation);\n                if (hoveredTarget) {\n                    piechart.hoveredIndex = hoveredTarget.index;\n                    piechart.draw();\n                } else if (piechart.hoveredIndex != -1) {\n                    piechart.hoveredIndex = -1;\n                    piechart.draw();\n                }\n                return;\n            }\n\n            var draggedPie = piechart.draggedPie;\n\n            var dx = dragLocation.x - draggedPie.centerX;\n            var dy = dragLocation.y - draggedPie.centerY;\n\n            // Get angle of grabbed target from centre of pie\n            var newAngle = Math.atan2(dy, dx) - draggedPie.angleOffset;\n\n            piechart.shiftSelectedAngle(newAngle);\n            piechart.draw();\n        }\n\n        function getMouseLocation(evt) {\n            var rect = piechart.canvas.getBoundingClientRect();\n\n            if (evt.clientX) {\n                return {\n                    x: evt.clientX - rect.left,\n                    y: evt.clientY - rect.top\n                }\n            } else {\n                return {\n                    x: evt.targetTouches[0].clientX - rect.left,\n                    y: evt.targetTouches[0].clientY - rect.top\n                }\n            }\n        }\n\n        /*\n         * Generates angle data from proportions (array of objects with proportion, format\n         */\n        function generateDataFromProportions(proportions) {\n\n            // sum of proportions\n            var total = proportions.reduce(function (a, v) {\n                return a + v.proportion;\n            }, 0);\n\n            // begin at 0\n            var currentAngle = 0;\n\n            // use the proportions to reconstruct angles\n            return proportions.map(function (v, i) {\n                var arcSize = TAU * v.proportion / total;\n                var data = {\n                    angle: currentAngle,\n                    format: v.format,\n                    collapsed: arcSize <= 0\n                };\n                currentAngle = normaliseAngle(currentAngle + arcSize);\n                return data;\n            });\n\n        }\n\n    };\n\n    /*\n     * Move angle specified by index: i, by amount: angle in rads\n     */\n    DraggablePiechart.prototype.moveAngle = function (i, amount) {\n\n        if (this.data[i].collapsed && amount < 0) {\n            this.setCollapsed(i, false);\n            return;\n        }\n\n        var geometry = this.getGeometry();\n        this.draggedPie = {\n            index: i,\n            angleOffset: 0,\n            centerX: geometry.centerX,\n            centerY: geometry.centerY,\n            startingAngles: this.data.map(function (v) {\n                return v.angle;\n            }),\n            collapsed: this.data.map(function (v) {\n                return v.collapsed;\n            }),\n            angleDragDistance: 0\n        };\n\n        this.shiftSelectedAngle(this.data[i].angle + amount);\n        this.draggedPie = null;\n        this.draw();\n    };\n\n    /*\n     * Gets percentage of indexed slice\n     */\n    DraggablePiechart.prototype.getSliceSizePercentage = function (index) {\n        var visibleSegments = this.getVisibleSegments();\n\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n            if (visibleSegments[i].index == index) {\n                return 100 * visibleSegments[i].arcSize / TAU;\n            }\n        }\n        return 0;\n    };\n\n    /*\n     * Gets all percentages for each slice\n     */\n    DraggablePiechart.prototype.getAllSliceSizePercentages = function () {\n        var visibleSegments = this.getVisibleSegments();\n        var percentages = [];\n        for (var i = 0; i < this.data.length; i += 1) {\n\n            if (this.data[i].collapsed) {\n                percentages[i] = 0;\n            } else {\n                for (var j = 0; j < visibleSegments.length; j += 1) {\n                    if (visibleSegments[j].index == i) {\n                        percentages[i] = 100 * visibleSegments[j].arcSize / TAU;\n                    }\n                }\n            }\n\n        }\n\n        return percentages;\n    };\n\n    /*\n     * Gets the geometry of the pie chart in the canvas\n     */\n    DraggablePiechart.prototype.getGeometry = function () {\n        var centerX = Math.floor(this.canvas.width / 2);\n        var centerY = Math.floor(this.canvas.height / 2);\n        return {\n            centerX: centerX,\n            centerY: centerY,\n            radius: Math.min(centerX, centerY) * this.radius\n        }\n    };\n\n    /*\n     * Returns a segment to drag if given a close enough location\n     */\n    DraggablePiechart.prototype.getTarget = function (targetLocation) {\n\n        var geometry = this.getGeometry();\n        var startingAngles = [];\n        var collapsed = [];\n\n        var closest = {\n            index: -1,\n            distance: 9999999,\n            angle: null\n        };\n\n        for (var i = 0; i < this.data.length; i += 1) {\n\n            startingAngles.push(this.data[i].angle);\n            collapsed.push(this.data[i].collapsed);\n\n            if (this.data[i].collapsed) {\n                continue;\n            }\n\n\n            var dx = targetLocation.x - geometry.centerX;\n            var dy = targetLocation.y - geometry.centerY;\n            var trueGrabbedAngle = Math.atan2(dy, dx);\n\n            var distance = Math.abs(smallestSignedAngleBetween(trueGrabbedAngle, this.data[i].angle));\n\n            if (distance < closest.distance) {\n                closest.index = i;\n                closest.distance = distance;\n                closest.angle = trueGrabbedAngle;\n            }\n        }\n\n        if (closest.distance < 0.1) {\n\n            return {\n                index: closest.index,\n                angleOffset: smallestSignedAngleBetween(closest.angle, startingAngles[closest.index]),\n                centerX: geometry.centerX,\n                centerY: geometry.centerY,\n                startingAngles: startingAngles,\n                collapsed: collapsed,\n                angleDragDistance: 0\n            }\n        } else {\n            return null;\n        }\n    };\n\n    /*\n     * Sets segments collapsed or uncollapsed\n     */\n    DraggablePiechart.prototype.setCollapsed = function (index, collapsed) {\n\n        // Flag to set position of previously collapsed to new location\n        var setNewPos = this.data[index].collapsed && !collapsed;\n\n        this.data[index].collapsed = collapsed;\n\n        var visibleSegments = this.getVisibleSegments();\n\n        // Shift other segments along to make space if necessary\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n\n            // Start at this segment\n            if (visibleSegments[i].index == index) {\n\n                //Set new position\n                if (setNewPos) {\n                    var nextSegment = visibleSegments[mod(i + 1, visibleSegments.length)];\n                    this.data[index].angle = nextSegment.angle - this.minAngle;\n                }\n\n                for (var j = 0; j < (visibleSegments.length - 1); j += 1) {\n                    var currentSegment = visibleSegments[mod(1 + i - j, visibleSegments.length)];\n                    var nextAlongSegment = visibleSegments[mod(i - j, visibleSegments.length)];\n\n                    var angleBetween = Math.abs(smallestSignedAngleBetween(this.data[currentSegment.index].angle, this.data[nextAlongSegment.index].angle));\n\n                    if (angleBetween < this.minAngle) {\n                        this.data[nextAlongSegment.index].angle = normaliseAngle(this.data[currentSegment.index].angle - this.minAngle);\n                    }\n\n                }\n                break;\n            }\n        }\n\n        this.draw();\n    };\n\n    /*\n     * Returns visible segments\n     */\n    DraggablePiechart.prototype.getVisibleSegments = function () {\n\n        var piechart = this;\n        // Collect data for visible segments\n        var visibleSegments = [];\n        for (var i = 0; i < piechart.data.length; i += 1) {\n\n            if (!piechart.data[i].collapsed) {\n                var startingAngle = piechart.data[i].angle;\n\n                // Get arcSize\n                var foundNextAngle = false;\n                for (var j = 1; j < piechart.data.length; j += 1) {\n                    var nextAngleIndex = (i + j) % piechart.data.length;\n\n                    if (!piechart.data[nextAngleIndex].collapsed) {\n                        var arcSize = piechart.data[nextAngleIndex].angle - startingAngle;\n                        if (arcSize <= 0) {\n                            arcSize += TAU;\n                        }\n\n                        visibleSegments.push({\n                            arcSize: arcSize,\n                            angle: startingAngle,\n                            format: piechart.data[i].format,\n                            index: i\n                        });\n\n                        foundNextAngle = true;\n                        break;\n                    }\n                }\n\n                // Only one segment\n                if (!foundNextAngle) {\n                    visibleSegments.push({\n                        arcSize: TAU,\n                        angle: startingAngle,\n                        format: piechart.data[i].format,\n                        index: i\n                    });\n                    break;\n                }\n            }\n\n        }\n        return visibleSegments;\n    };\n\n    /*\n     * Returns invisible segments\n     */\n    DraggablePiechart.prototype.getInvisibleSegments = function () {\n        var piechart = this;\n        // Collect data for visible segments\n        var invisibleSegments = [];\n        for (var i = 0; i < piechart.data.length; i += 1) {\n            if (piechart.data[i].collapsed) {\n                invisibleSegments.push({\n                    index: i,\n                    format: piechart.data[i].format\n                })\n            }\n        }\n\n        return invisibleSegments;\n    };\n\n    /*\n     * Draws the piechart\n     */\n    DraggablePiechart.prototype.draw = function () {\n        var piechart = this;\n        var context = piechart.context;\n        var canvas = piechart.canvas;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        var geometry = this.getGeometry();\n\n        var visibleSegments = this.getVisibleSegments();\n\n        // Flags to get arc sizes and index of largest arc, for drawing order\n        var largestArcSize = 0;\n        var indexLargestArcSize = -1;\n\n        // Get the largeset arcsize\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n            if (visibleSegments[i].arcSize > largestArcSize) {\n                largestArcSize = visibleSegments[i].arcSize;\n                indexLargestArcSize = i;\n            }\n        }\n\n\n        // Need to draw in correct order\n        for (i = 0; i < visibleSegments.length; i += 1) {\n\n            // Start with one *after* largest\n            var index = mod(i + indexLargestArcSize + 1, visibleSegments.length);\n            piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, visibleSegments[index].angle, visibleSegments[index].arcSize, visibleSegments[index].format, false);\n        }\n\n        // Now draw invisible segments\n        var invisibleSegments = this.getInvisibleSegments();\n        for (i = 0; i < invisibleSegments.length; i += 1) {\n            piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, 0, 0, invisibleSegments[i].format, true);\n        }\n\n        // Finally draw drag nodes on top (order not important)\n        for (i = 0; i < visibleSegments.length; i += 1) {\n            var location = polarToCartesian(visibleSegments[i].angle, geometry.radius);\n            piechart.drawNode(context, piechart, location.x, location.y, geometry.centerX, geometry.centerY, i == piechart.hoveredIndex);\n        }\n\n        piechart.onchange(piechart);\n\n    };\n\n    /*\n     * *INTERNAL USE ONLY*\n     * Moves the selected angle to a new angle\n     */\n    DraggablePiechart.prototype.shiftSelectedAngle = function (newAngle) {\n        var piechart = this;\n        if (!piechart.draggedPie) {\n            return;\n        }\n        var draggedPie = piechart.draggedPie;\n\n\n        // Get starting angle of the target\n        var startingAngle = draggedPie.startingAngles[draggedPie.index];\n\n        // Get previous angle of the target\n        var previousAngle = piechart.data[draggedPie.index].angle;\n\n        // Get diff from grabbed target start (as -pi to +pi)\n        var angleDragDistance = smallestSignedAngleBetween(newAngle, startingAngle);\n\n        // Get previous diff\n        var previousDragDistance = draggedPie.angleDragDistance;\n\n        // Determines whether we go clockwise or anticlockwise\n        var rotationDirection = previousDragDistance > 0 ? 1 : -1;\n\n\n        // Reverse the direction if we have done over 180 in either direction\n        var sameDirection = previousDragDistance > 0 == angleDragDistance > 0;\n        var greaterThanHalf = Math.abs(previousDragDistance - angleDragDistance) > Math.PI;\n\n\n        if (greaterThanHalf && !sameDirection) {\n            // Reverse the angle\n            angleDragDistance = (TAU - Math.abs(angleDragDistance)) * rotationDirection;\n        } else {\n            rotationDirection = angleDragDistance > 0 ? 1 : -1;\n        }\n\n        draggedPie.angleDragDistance = angleDragDistance;\n\n\n        // Set the new angle:\n        piechart.data[draggedPie.index].angle = normaliseAngle(startingAngle + angleDragDistance);\n\n        // Reset Collapse\n        piechart.data[draggedPie.index].collapsed = draggedPie.collapsed[draggedPie.index];\n\n        // Search other angles\n        var shifting = true;\n        var collapsed = false;\n        var minAngle = piechart.minAngle;\n        var numberOfAnglesShifted = 0;\n\n        for (var i = 1; i < piechart.data.length; i += 1) {\n\n            // Index to test each slice in order\n            var index = mod(parseInt(draggedPie.index) + (i * rotationDirection), piechart.data.length);\n\n            // Get angle from target start to this angle\n            var startingAngleToNonDragged = smallestSignedAngleBetween(draggedPie.startingAngles[index], startingAngle);\n\n            // If angle is in the wrong direction then it should actually be OVER 180\n            if (startingAngleToNonDragged * rotationDirection < 0) {\n                startingAngleToNonDragged = ((startingAngleToNonDragged * rotationDirection) + TAU) * rotationDirection;\n            }\n\n            if (piechart.collapsing) {\n                // *Collapsing behaviour* when smallest angle encountered\n\n                // Reset collapse\n                piechart.data[index].collapsed = draggedPie.collapsed[index];\n\n                var checkForSnap = !collapsed && !piechart.data[index].collapsed;\n\n                // Snap node to collapse, and prevent going any further\n                if (checkForSnap && startingAngleToNonDragged > 0 && angleDragDistance > (startingAngleToNonDragged - minAngle)) {\n                    piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n                    piechart.data[draggedPie.index].collapsed = true;\n                    collapsed = true;\n                } else if (checkForSnap && startingAngleToNonDragged < 0 && angleDragDistance < (startingAngleToNonDragged + minAngle)) {\n                    piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n                    piechart.data[index].collapsed = true;\n                    collapsed = true;\n                } else {\n                    piechart.data[index].angle = draggedPie.startingAngles[index];\n\n                }\n            } else {\n                // *Shifting behaviour* when smallest angle encountered\n\n                // Shift all other angles along\n                var shift = (numberOfAnglesShifted + 1) * minAngle;\n\n                if (shifting && startingAngleToNonDragged > 0 && angleDragDistance > (startingAngleToNonDragged - shift)) {\n                    piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] + (angleDragDistance - startingAngleToNonDragged) + shift);\n                    numberOfAnglesShifted += 1;\n                } else if (shifting && startingAngleToNonDragged < 0 && angleDragDistance < (startingAngleToNonDragged + shift)) {\n                    piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] - (startingAngleToNonDragged - angleDragDistance) - shift);\n                    numberOfAnglesShifted += 1;\n                } else {\n                    shifting = false;\n                    piechart.data[index].angle = draggedPie.startingAngles[index];\n                }\n            }\n\n            //console.log(JSON.stringify(piechart.data));\n\n        }\n\n\n    };\n\n    DraggablePiechart.prototype.defaults = {\n\n        onchange: function (piechart) {\n        },\n        radius: 0.9,\n        data: [\n            {angle: -2, format: {color: \"#2665da\", label: 'Walking'}, collapsed: false},\n            {angle: -1, format: {color: \"#6dd020\", label: 'Programming'}, collapsed: false},\n            {angle: 0, format: {color: \"#f9df18\", label: 'Chess'}, collapsed: false},\n            {angle: 1, format: {color: \"#d42a00\", label: 'Eating'}, collapsed: false},\n            {angle: 2, format: {color: \"#e96400\", label: 'Sleeping'}, collapsed: false}],\n        collapsing: false,\n        minAngle: 0.1,\n\n        drawSegment: function (context, piechart, centerX, centerY, radius, startingAngle, arcSize, format, collapsed) {\n\n            if (collapsed) {\n                return;\n            }\n\n            // Draw coloured segment\n            context.save();\n            var endingAngle = startingAngle + arcSize;\n            context.beginPath();\n            context.moveTo(centerX, centerY);\n            context.arc(centerX, centerY, radius,\n                startingAngle, endingAngle, false);\n            context.closePath();\n\n            context.fillStyle = format.color;\n            context.fill();\n            context.restore();\n\n            // Draw label on top\n            context.save();\n            context.translate(centerX, centerY);\n            context.rotate(startingAngle);\n\n            var fontSize = Math.floor(context.canvas.height / 25);\n            var dx = radius - fontSize;\n            var dy = centerY / 10;\n\n            context.textAlign = \"right\";\n            context.font = fontSize + \"pt Helvetica\";\n            context.fillText(format.label, dx, dy);\n            context.restore();\n        },\n\n        drawNode: function (context, piechart, x, y, centerX, centerY, hover) {\n\n            context.save();\n            context.translate(centerX, centerY);\n            context.fillStyle = '#DDDDDD';\n\n            var rad = hover ? 7 : 5;\n            context.beginPath();\n            context.arc(x, y, rad, 0, TAU, true);\n            context.fill();\n            context.stroke();\n            context.restore();\n        }\n    };\n\n    window.DraggablePiechart = DraggablePiechart;\n\n    /*\n     * Utilities + Constants\n     */\n\n    var TAU = Math.PI * 2;\n\n    function degreesToRadians(degrees) {\n        return (degrees * Math.PI) / 180;\n    }\n\n    function smallestSignedAngleBetween(target, source) {\n        return Math.atan2(Math.sin(target - source), Math.cos(target - source));\n    }\n\n    function mod(n, m) {\n        return ((n % m) + m) % m;\n    }\n\n    function normaliseAngle(angle) {\n        return mod(angle + Math.PI, TAU) - Math.PI;\n    }\n\n    function polarToCartesian(angle, radius) {\n        return {\n            x: radius * Math.cos(angle),\n            y: radius * Math.sin(angle)\n        }\n    }\n\n})();\n\n"]},"metadata":{},"sourceType":"module"}