{"version":3,"file":"js/draggable-piechart-8e9d0cf45fe7df709e56.js","sources":["webpack:///webpack/bootstrap","webpack:///./app/javascript/packs/draggable-piechart.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/packs/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./app/javascript/packs/draggable-piechart.js\");\n","/**\n * Created by james on 23/02/2017.\n */\n\n(function () {\n\n    var extend = function (out) {\n        out = out || {};\n\n        for (var i = 1; i < arguments.length; i++) {\n            if (!arguments[i])\n                continue;\n\n            for (var key in arguments[i]) {\n                if (arguments[i].hasOwnProperty(key))\n                    out[key] = arguments[i][key];\n            }\n        }\n\n        return out;\n    };\n\n    var DraggablePiechart = function (setup) {\n\n        var piechart = this;\n\n        setup = extend({}, this.defaults, setup);\n\n        this.canvas = setup.canvas;\n        this.context = setup.canvas.getContext(\"2d\");\n\n        if (!this.context) {\n            console.log('Error: DraggablePiechart needs an html5 canvas.');\n            return;\n        }\n\n        if (setup.proportions) {\n            this.data = generateDataFromProportions(setup.proportions);\n        } else if (setup.data) {\n            this.data = setup.data;\n        }\n\n        this.draggedPie = null;\n        this.hoveredIndex = -1;\n        this.radius = setup.radius;\n        this.collapsing = setup.collapsing;\n        this.minAngle = setup.minAngle;\n        this.drawSegment = setup.drawSegment;\n        this.drawNode = setup.drawNode;\n        this.onchange = setup.onchange;\n\n\n        // Bind appropriate events\n\n        this.canvas.addEventListener('touchstart', function (e) {\n            touchStart(e);\n            e.preventDefault();\n        });\n        this.canvas.addEventListener('touchmove', function (e) {\n            touchMove(e);\n            e.preventDefault();\n        });\n        document.addEventListener('touchend', function (e) {\n            touchEnd(e);\n        });\n\n        this.canvas.addEventListener('mousedown', touchStart);\n        this.canvas.addEventListener('mousemove', touchMove);\n        document.addEventListener('mouseup', touchEnd);\n\n\n        this.draw();\n\n        function touchStart(event) {\n\n            piechart.draggedPie = piechart.getTarget(getMouseLocation(event));\n            if (piechart.draggedPie) {\n                piechart.hoveredIndex = piechart.draggedPie.index;\n            }\n        }\n\n        function touchEnd() {\n\n            if (piechart.draggedPie) {\n                piechart.draggedPie = null;\n                piechart.draw();\n            }\n        }\n\n        function touchMove(event) {\n            var dragLocation = getMouseLocation(event);\n\n            if (!piechart.draggedPie) {\n                var hoveredTarget = piechart.getTarget(dragLocation);\n                if (hoveredTarget) {\n                    piechart.hoveredIndex = hoveredTarget.index;\n                    piechart.draw();\n                } else if (piechart.hoveredIndex != -1) {\n                    piechart.hoveredIndex = -1;\n                    piechart.draw();\n                }\n                return;\n            }\n\n            var draggedPie = piechart.draggedPie;\n\n            var dx = dragLocation.x - draggedPie.centerX;\n            var dy = dragLocation.y - draggedPie.centerY;\n\n            // Get angle of grabbed target from centre of pie\n            var newAngle = Math.atan2(dy, dx) - draggedPie.angleOffset;\n\n            piechart.shiftSelectedAngle(newAngle);\n            piechart.draw();\n        }\n\n        function getMouseLocation(evt) {\n            var rect = piechart.canvas.getBoundingClientRect();\n\n            if (evt.clientX) {\n                return {\n                    x: evt.clientX - rect.left,\n                    y: evt.clientY - rect.top\n                }\n            } else {\n                return {\n                    x: evt.targetTouches[0].clientX - rect.left,\n                    y: evt.targetTouches[0].clientY - rect.top\n                }\n            }\n        }\n\n        /*\n         * Generates angle data from proportions (array of objects with proportion, format\n         */\n        function generateDataFromProportions(proportions) {\n\n            // sum of proportions\n            var total = proportions.reduce(function (a, v) {\n                return a + v.proportion;\n            }, 0);\n\n            // begin at 0\n            var currentAngle = 0;\n\n            // use the proportions to reconstruct angles\n            return proportions.map(function (v, i) {\n                var arcSize = TAU * v.proportion / total;\n                var data = {\n                    angle: currentAngle,\n                    format: v.format,\n                    collapsed: arcSize <= 0\n                };\n                currentAngle = normaliseAngle(currentAngle + arcSize);\n                return data;\n            });\n\n        }\n\n    };\n\n    /*\n     * Move angle specified by index: i, by amount: angle in rads\n     */\n    DraggablePiechart.prototype.moveAngle = function (i, amount) {\n\n        if (this.data[i].collapsed && amount < 0) {\n            this.setCollapsed(i, false);\n            return;\n        }\n\n        var geometry = this.getGeometry();\n        this.draggedPie = {\n            index: i,\n            angleOffset: 0,\n            centerX: geometry.centerX,\n            centerY: geometry.centerY,\n            startingAngles: this.data.map(function (v) {\n                return v.angle;\n            }),\n            collapsed: this.data.map(function (v) {\n                return v.collapsed;\n            }),\n            angleDragDistance: 0\n        };\n\n        this.shiftSelectedAngle(this.data[i].angle + amount);\n        this.draggedPie = null;\n        this.draw();\n    };\n\n    /*\n     * Gets percentage of indexed slice\n     */\n    DraggablePiechart.prototype.getSliceSizePercentage = function (index) {\n        var visibleSegments = this.getVisibleSegments();\n\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n            if (visibleSegments[i].index == index) {\n                return 100 * visibleSegments[i].arcSize / TAU;\n            }\n        }\n        return 0;\n    };\n\n    /*\n     * Gets all percentages for each slice\n     */\n    DraggablePiechart.prototype.getAllSliceSizePercentages = function () {\n        var visibleSegments = this.getVisibleSegments();\n        var percentages = [];\n        for (var i = 0; i < this.data.length; i += 1) {\n\n            if (this.data[i].collapsed) {\n                percentages[i] = 0;\n            } else {\n                for (var j = 0; j < visibleSegments.length; j += 1) {\n                    if (visibleSegments[j].index == i) {\n                        percentages[i] = 100 * visibleSegments[j].arcSize / TAU;\n                    }\n                }\n            }\n\n        }\n\n        return percentages;\n    };\n\n    /*\n     * Gets the geometry of the pie chart in the canvas\n     */\n    DraggablePiechart.prototype.getGeometry = function () {\n        var centerX = Math.floor(this.canvas.width / 2);\n        var centerY = Math.floor(this.canvas.height / 2);\n        return {\n            centerX: centerX,\n            centerY: centerY,\n            radius: Math.min(centerX, centerY) * this.radius\n        }\n    };\n\n    /*\n     * Returns a segment to drag if given a close enough location\n     */\n    DraggablePiechart.prototype.getTarget = function (targetLocation) {\n\n        var geometry = this.getGeometry();\n        var startingAngles = [];\n        var collapsed = [];\n\n        var closest = {\n            index: -1,\n            distance: 9999999,\n            angle: null\n        };\n\n        for (var i = 0; i < this.data.length; i += 1) {\n\n            startingAngles.push(this.data[i].angle);\n            collapsed.push(this.data[i].collapsed);\n\n            if (this.data[i].collapsed) {\n                continue;\n            }\n\n\n            var dx = targetLocation.x - geometry.centerX;\n            var dy = targetLocation.y - geometry.centerY;\n            var trueGrabbedAngle = Math.atan2(dy, dx);\n\n            var distance = Math.abs(smallestSignedAngleBetween(trueGrabbedAngle, this.data[i].angle));\n\n            if (distance < closest.distance) {\n                closest.index = i;\n                closest.distance = distance;\n                closest.angle = trueGrabbedAngle;\n            }\n        }\n\n        if (closest.distance < 0.1) {\n\n            return {\n                index: closest.index,\n                angleOffset: smallestSignedAngleBetween(closest.angle, startingAngles[closest.index]),\n                centerX: geometry.centerX,\n                centerY: geometry.centerY,\n                startingAngles: startingAngles,\n                collapsed: collapsed,\n                angleDragDistance: 0\n            }\n        } else {\n            return null;\n        }\n    };\n\n    /*\n     * Sets segments collapsed or uncollapsed\n     */\n    DraggablePiechart.prototype.setCollapsed = function (index, collapsed) {\n\n        // Flag to set position of previously collapsed to new location\n        var setNewPos = this.data[index].collapsed && !collapsed;\n\n        this.data[index].collapsed = collapsed;\n\n        var visibleSegments = this.getVisibleSegments();\n\n        // Shift other segments along to make space if necessary\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n\n            // Start at this segment\n            if (visibleSegments[i].index == index) {\n\n                //Set new position\n                if (setNewPos) {\n                    var nextSegment = visibleSegments[mod(i + 1, visibleSegments.length)];\n                    this.data[index].angle = nextSegment.angle - this.minAngle;\n                }\n\n                for (var j = 0; j < (visibleSegments.length - 1); j += 1) {\n                    var currentSegment = visibleSegments[mod(1 + i - j, visibleSegments.length)];\n                    var nextAlongSegment = visibleSegments[mod(i - j, visibleSegments.length)];\n\n                    var angleBetween = Math.abs(smallestSignedAngleBetween(this.data[currentSegment.index].angle, this.data[nextAlongSegment.index].angle));\n\n                    if (angleBetween < this.minAngle) {\n                        this.data[nextAlongSegment.index].angle = normaliseAngle(this.data[currentSegment.index].angle - this.minAngle);\n                    }\n\n                }\n                break;\n            }\n        }\n\n        this.draw();\n    };\n\n    /*\n     * Returns visible segments\n     */\n    DraggablePiechart.prototype.getVisibleSegments = function () {\n\n        var piechart = this;\n        // Collect data for visible segments\n        var visibleSegments = [];\n        for (var i = 0; i < piechart.data.length; i += 1) {\n\n            if (!piechart.data[i].collapsed) {\n                var startingAngle = piechart.data[i].angle;\n\n                // Get arcSize\n                var foundNextAngle = false;\n                for (var j = 1; j < piechart.data.length; j += 1) {\n                    var nextAngleIndex = (i + j) % piechart.data.length;\n\n                    if (!piechart.data[nextAngleIndex].collapsed) {\n                        var arcSize = piechart.data[nextAngleIndex].angle - startingAngle;\n                        if (arcSize <= 0) {\n                            arcSize += TAU;\n                        }\n\n                        visibleSegments.push({\n                            arcSize: arcSize,\n                            angle: startingAngle,\n                            format: piechart.data[i].format,\n                            index: i\n                        });\n\n                        foundNextAngle = true;\n                        break;\n                    }\n                }\n\n                // Only one segment\n                if (!foundNextAngle) {\n                    visibleSegments.push({\n                        arcSize: TAU,\n                        angle: startingAngle,\n                        format: piechart.data[i].format,\n                        index: i\n                    });\n                    break;\n                }\n            }\n\n        }\n        return visibleSegments;\n    };\n\n    /*\n     * Returns invisible segments\n     */\n    DraggablePiechart.prototype.getInvisibleSegments = function () {\n        var piechart = this;\n        // Collect data for visible segments\n        var invisibleSegments = [];\n        for (var i = 0; i < piechart.data.length; i += 1) {\n            if (piechart.data[i].collapsed) {\n                invisibleSegments.push({\n                    index: i,\n                    format: piechart.data[i].format\n                })\n            }\n        }\n\n        return invisibleSegments;\n    };\n\n    /*\n     * Draws the piechart\n     */\n    DraggablePiechart.prototype.draw = function () {\n        var piechart = this;\n        var context = piechart.context;\n        var canvas = piechart.canvas;\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        var geometry = this.getGeometry();\n\n        var visibleSegments = this.getVisibleSegments();\n\n        // Flags to get arc sizes and index of largest arc, for drawing order\n        var largestArcSize = 0;\n        var indexLargestArcSize = -1;\n\n        // Get the largeset arcsize\n        for (var i = 0; i < visibleSegments.length; i += 1) {\n            if (visibleSegments[i].arcSize > largestArcSize) {\n                largestArcSize = visibleSegments[i].arcSize;\n                indexLargestArcSize = i;\n            }\n        }\n\n\n        // Need to draw in correct order\n        for (i = 0; i < visibleSegments.length; i += 1) {\n\n            // Start with one *after* largest\n            var index = mod(i + indexLargestArcSize + 1, visibleSegments.length);\n            piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, visibleSegments[index].angle, visibleSegments[index].arcSize, visibleSegments[index].format, false);\n        }\n\n        // Now draw invisible segments\n        var invisibleSegments = this.getInvisibleSegments();\n        for (i = 0; i < invisibleSegments.length; i += 1) {\n            piechart.drawSegment(context, piechart, geometry.centerX, geometry.centerY, geometry.radius, 0, 0, invisibleSegments[i].format, true);\n        }\n\n        // Finally draw drag nodes on top (order not important)\n        for (i = 0; i < visibleSegments.length; i += 1) {\n            var location = polarToCartesian(visibleSegments[i].angle, geometry.radius);\n            piechart.drawNode(context, piechart, location.x, location.y, geometry.centerX, geometry.centerY, i == piechart.hoveredIndex);\n        }\n\n        piechart.onchange(piechart);\n\n    };\n\n    /*\n     * *INTERNAL USE ONLY*\n     * Moves the selected angle to a new angle\n     */\n    DraggablePiechart.prototype.shiftSelectedAngle = function (newAngle) {\n        var piechart = this;\n        if (!piechart.draggedPie) {\n            return;\n        }\n        var draggedPie = piechart.draggedPie;\n\n\n        // Get starting angle of the target\n        var startingAngle = draggedPie.startingAngles[draggedPie.index];\n\n        // Get previous angle of the target\n        var previousAngle = piechart.data[draggedPie.index].angle;\n\n        // Get diff from grabbed target start (as -pi to +pi)\n        var angleDragDistance = smallestSignedAngleBetween(newAngle, startingAngle);\n\n        // Get previous diff\n        var previousDragDistance = draggedPie.angleDragDistance;\n\n        // Determines whether we go clockwise or anticlockwise\n        var rotationDirection = previousDragDistance > 0 ? 1 : -1;\n\n\n        // Reverse the direction if we have done over 180 in either direction\n        var sameDirection = previousDragDistance > 0 == angleDragDistance > 0;\n        var greaterThanHalf = Math.abs(previousDragDistance - angleDragDistance) > Math.PI;\n\n\n        if (greaterThanHalf && !sameDirection) {\n            // Reverse the angle\n            angleDragDistance = (TAU - Math.abs(angleDragDistance)) * rotationDirection;\n        } else {\n            rotationDirection = angleDragDistance > 0 ? 1 : -1;\n        }\n\n        draggedPie.angleDragDistance = angleDragDistance;\n\n\n        // Set the new angle:\n        piechart.data[draggedPie.index].angle = normaliseAngle(startingAngle + angleDragDistance);\n\n        // Reset Collapse\n        piechart.data[draggedPie.index].collapsed = draggedPie.collapsed[draggedPie.index];\n\n        // Search other angles\n        var shifting = true;\n        var collapsed = false;\n        var minAngle = piechart.minAngle;\n        var numberOfAnglesShifted = 0;\n\n        for (var i = 1; i < piechart.data.length; i += 1) {\n\n            // Index to test each slice in order\n            var index = mod(parseInt(draggedPie.index) + (i * rotationDirection), piechart.data.length);\n\n            // Get angle from target start to this angle\n            var startingAngleToNonDragged = smallestSignedAngleBetween(draggedPie.startingAngles[index], startingAngle);\n\n            // If angle is in the wrong direction then it should actually be OVER 180\n            if (startingAngleToNonDragged * rotationDirection < 0) {\n                startingAngleToNonDragged = ((startingAngleToNonDragged * rotationDirection) + TAU) * rotationDirection;\n            }\n\n            if (piechart.collapsing) {\n                // *Collapsing behaviour* when smallest angle encountered\n\n                // Reset collapse\n                piechart.data[index].collapsed = draggedPie.collapsed[index];\n\n                var checkForSnap = !collapsed && !piechart.data[index].collapsed;\n\n                // Snap node to collapse, and prevent going any further\n                if (checkForSnap && startingAngleToNonDragged > 0 && angleDragDistance > (startingAngleToNonDragged - minAngle)) {\n                    piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n                    piechart.data[draggedPie.index].collapsed = true;\n                    collapsed = true;\n                } else if (checkForSnap && startingAngleToNonDragged < 0 && angleDragDistance < (startingAngleToNonDragged + minAngle)) {\n                    piechart.data[draggedPie.index].angle = piechart.data[index].angle;\n                    piechart.data[index].collapsed = true;\n                    collapsed = true;\n                } else {\n                    piechart.data[index].angle = draggedPie.startingAngles[index];\n\n                }\n            } else {\n                // *Shifting behaviour* when smallest angle encountered\n\n                // Shift all other angles along\n                var shift = (numberOfAnglesShifted + 1) * minAngle;\n\n                if (shifting && startingAngleToNonDragged > 0 && angleDragDistance > (startingAngleToNonDragged - shift)) {\n                    piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] + (angleDragDistance - startingAngleToNonDragged) + shift);\n                    numberOfAnglesShifted += 1;\n                } else if (shifting && startingAngleToNonDragged < 0 && angleDragDistance < (startingAngleToNonDragged + shift)) {\n                    piechart.data[index].angle = normaliseAngle(draggedPie.startingAngles[index] - (startingAngleToNonDragged - angleDragDistance) - shift);\n                    numberOfAnglesShifted += 1;\n                } else {\n                    shifting = false;\n                    piechart.data[index].angle = draggedPie.startingAngles[index];\n                }\n            }\n\n            //console.log(JSON.stringify(piechart.data));\n\n        }\n\n\n    };\n\n    DraggablePiechart.prototype.defaults = {\n\n        onchange: function (piechart) {\n        },\n        radius: 0.9,\n        data: [\n            {angle: -2, format: {color: \"#2665da\", label: 'Walking'}, collapsed: false},\n            {angle: -1, format: {color: \"#6dd020\", label: 'Programming'}, collapsed: false},\n            {angle: 0, format: {color: \"#f9df18\", label: 'Chess'}, collapsed: false},\n            {angle: 1, format: {color: \"#d42a00\", label: 'Eating'}, collapsed: false},\n            {angle: 2, format: {color: \"#e96400\", label: 'Sleeping'}, collapsed: false}],\n        collapsing: false,\n        minAngle: 0.1,\n\n        drawSegment: function (context, piechart, centerX, centerY, radius, startingAngle, arcSize, format, collapsed) {\n\n            if (collapsed) {\n                return;\n            }\n\n            // Draw coloured segment\n            context.save();\n            var endingAngle = startingAngle + arcSize;\n            context.beginPath();\n            context.moveTo(centerX, centerY);\n            context.arc(centerX, centerY, radius,\n                startingAngle, endingAngle, false);\n            context.closePath();\n\n            context.fillStyle = format.color;\n            context.fill();\n            context.restore();\n\n            // Draw label on top\n            context.save();\n            context.translate(centerX, centerY);\n            context.rotate(startingAngle);\n\n            var fontSize = Math.floor(context.canvas.height / 25);\n            var dx = radius - fontSize;\n            var dy = centerY / 10;\n\n            context.textAlign = \"right\";\n            context.font = fontSize + \"pt Helvetica\";\n            context.fillText(format.label, dx, dy);\n            context.restore();\n        },\n\n        drawNode: function (context, piechart, x, y, centerX, centerY, hover) {\n\n            context.save();\n            context.translate(centerX, centerY);\n            context.fillStyle = '#DDDDDD';\n\n            var rad = hover ? 7 : 5;\n            context.beginPath();\n            context.arc(x, y, rad, 0, TAU, true);\n            context.fill();\n            context.stroke();\n            context.restore();\n        }\n    };\n\n    window.DraggablePiechart = DraggablePiechart;\n\n    /*\n     * Utilities + Constants\n     */\n\n    var TAU = Math.PI * 2;\n\n    function degreesToRadians(degrees) {\n        return (degrees * Math.PI) / 180;\n    }\n\n    function smallestSignedAngleBetween(target, source) {\n        return Math.atan2(Math.sin(target - source), Math.cos(target - source));\n    }\n\n    function mod(n, m) {\n        return ((n % m) + m) % m;\n    }\n\n    function normaliseAngle(angle) {\n        return mod(angle + Math.PI, TAU) - Math.PI;\n    }\n\n    function polarToCartesian(angle, radius) {\n        return {\n            x: radius * Math.cos(angle),\n            y: radius * Math.sin(angle)\n        }\n    }\n\n})();\n\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAcA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAHA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA5DA;AA+DA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AAEA;;;;A","sourceRoot":""}